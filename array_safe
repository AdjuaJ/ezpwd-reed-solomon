#ifndef _ARRAY_SAFE
#define _ARRAY_SAFE

#include <array>

namespace ezpwd {
    //
    // array_safe  -- a std::array with bounds checking by default
    //
    using std::array;
    template < typename T, std::size_t S >
    struct array_safe
	: public array<T, S> {
	using typename array<T,S>::value_type;
	using typename array<T,S>::pointer;
	using typename array<T,S>::const_pointer;
	using typename array<T,S>::reference;
	using typename array<T,S>::const_reference;
	using typename array<T,S>::iterator;
	using typename array<T,S>::const_iterator;
	using typename array<T,S>::size_type;
	using typename array<T,S>::difference_type;
	using typename array<T,S>::reverse_iterator;
	using typename array<T,S>::const_reverse_iterator;

				array_safe()
				    : array<T,S>() {;}
				array_safe( const array<T,S> &rhs )
				    : array<T,S>( rhs ) {;}
				array_safe( const array<T,S> &&rhs )
				    : array<T,S>( rhs ) {;}

	using array<T,S>::fill;
	using array<T,S>::swap;
	using array<T,S>::begin;
	using array<T,S>::end;
	using array<T,S>::rbegin;
	using array<T,S>::rend;
	using array<T,S>::cbegin;
	using array<T,S>::cend;
	using array<T,S>::crbegin;
	using array<T,S>::crend;
	using array<T,S>::size;
	using array<T,S>::max_size;
	using array<T,S>::empty;
	using array<T,S>::at;
	using array<T,S>::front;
	using array<T,S>::back;
	using array<T,S>::data;
	reference		operator[]( size_type i )
	{
	    return at( i );
	}
	constexpr
	const_reference		operator[]( size_type i )
	    const
	{
	    return at( i );
	}
    };
} // namespace ezpwd

#endif // _ARRAY_SAFE
