#ifndef _EZPWD_EZCOD
#define _EZPWD_EZCOD

#include <math.h> // M_PI
#include <cmath>

#include <cstdint>
#include <ezpwd/rs>
#include <ezpwd/output>

// 
// EZCOD 3:10 location code w/ Reed-Solomon Error Correction, and average 3m accuracy
// 
// - each successive symbol provides greater precision
//   - codes nearby each-other are identical in leading characters
// - average 3m precision achieved in 9 symbols
//   - more than 4 base-10 digits of precision in both lat and lon after the decimal
// - from 1 to 3 symbols of Reed-Solomon parity
//   - 1 parity symbol supplies validation w/ strength equivalent to a check character
//   - 2 parity symbols provides correction of 1 lost symbol (no errors)
//   - 3 parity symbols provides correction of any 1 error, with verification,
//     or recovery of up to any 3 lost symbols (with no other errors)
// 

// 
//     To achieve at least 4 decimal digits of precision after the decimal point, we must have
// defined lat to within 1 part in 1,800,000, and lon to within 1 part in 3,600,000.  As each symbol
// supplies bits, we'll refine the computed lat/lon further, reducing the outstanding fraction of
// "parts" yet to be defined.
// 
//             bits      
//    symbols   latitude             longitude
//              bits mul   parts      bits mul   parts
//       1      2    4         4      3    8         8
//       2      2    4        16      3    8        64
//       3      3    8       128      2    4       256 // not quite integer lat/lon accuracy
// 
//       4      2    4       512      3    8     2,048
//       5      3    8     4,096      2    4     8,192
//       6      2    4    16,384      3    8    65,536 
//
//       7      3    8   131,072      2    4   262,144
//       8      2    4   524,288      3    8 2,097,152
//       9      3    8 4,194,304      2    4 8,388,608 parts resolution in  3:10 code
//                over [-90, 90]       over [-180,180] yields ~3m resolution
// 
//                 vs. 1,800,000             3,600,000 parts resolution in 10:10 code
//                over [-90, 90]       over [-180,180] yields ~10m resolution
// 
//     Therefore, within 9 symbols we define lat and lon with better than double the precision of
// 10:10 code's 4 decimal digits after the decimal point.  This yields an approximate lineal
// precision of 40,075,000m / 8,388,608 == ~5m in both dimensions at the equator, vs. 40,075,000m /
// 3,600,000 == ~11m for 10:10 codes.
// 
//     The 10:10 code provides a single check character, which provides about P(1-1/32) certainty
// that the provided code is correct.  With EZCOD 3:10/11/12 codes, we provide varying levels of 
// detection/correction strength.
// 
//   - 1 parity symbol: act as a check character (like 10:10 codes), or provide 1 symbol of erasure
//     (lost symbol) recovery with no excess parity for validation.
// 
//    - 2 parity symbols: provide 1 symbol of erasure correction (w/ no other errors) with 1 excess parity
//      symbol for validation, or 1 symbol of error detection with no excess parity for validation.
//             
//    - 3 parity symbols: correct 1 error anywhere w/ 1 excess parity symbol for validation, or up
//      to 3 erasures with no excess parity for validation.
// 
//     Therefore, we'll provide Reed-Solomon RS(31,28-30) error correction (5 bit symbols,
// indicating 31 symbols in the field, and from 1 to 3 roots, therefore up to 28 data symbols in the
// field) over the 9 lat/lon data symbols.
// 
// 
// MINIMIZING ERROR
// 
//     Each input lat/lon coordinate will be effectively truncated by the encoding procedure to the
// level of precision (parts) encoded by each symbol.  Subsequent symbols then add their (smaller)
// parts to increase precision.
// 
//     After the last symbol, we know that the actual input coordinates where somewhere
// within the square:
// 
//         [0,0] -> [0,lon_precision] -> [lat_precision,lon_precision] -> [lat_precision,0]
// 
//     At first glance, the best way is to perform rounding instead of truncation on ecoding, by
// simply adding 1/2 of the precision.  Then, the unmodified output lat/lon decoded represents the
// point nearest actual input coordinate.  However, this is NOT ideal.  Remember -- the decoding may
// not have access to all the symbols!  We want to minimize the error even if only some of the
// symbols are available.  Thus, we must apply a correction on decoding.
// 
//    One way gain rounding instead of truncation on decoding is, after adding the last symbol's
// precision, to add 50% of the value represented by the first bit of the next (missing) symbol's
// precision parts.  This would be analogous to receiving the first 2 digits of a 3 digit number:
// 
//         original:  123
//         received:  12_
//         range:     [120,130)
//         guessed:   125 (add 1/2 of the parts represented by the missing digit)
// 
//     If this is done, then the resulting coordinate would be in the middle of the square of
// possible input lat/lon values that could have resulted in the encoded value.  This also works if
// we don't receive and decode all of the symbols; We'll end up with a lat/lon in the middle of the
// (large) square of possible input coordinates.
// 


namespace ezpwd {
    // 
    // ezpwd::base32 -- transform individual characters between 5-bit binary and base32
    // 
    //     The char values [0,32) are mapped by base32::encode onto:
    // 
    //         ABCDEFGHJKLMNPQRTUVWXY0123456789
    // 
    // and base32::decode performs the inverse.  In addition to folding lower-case to upper-case,
    // the following mappings occur on decode:
    // 
    //    O -> 0
    //    Z -> 2
    //    S -> 5
    //    I -> 1
    // 
    //    Any characters encountered outside [0,32) by encode and outsside the above set
    // by decode raise an exception.
    // 
    namespace base32 {

	static const ezpwd::array<int,32> chrs = { { // Must be in sorted order
		'0', '1', '2', '3', '4', '5', '6', '7',
		'8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
		'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P',
		'Q', 'R', 'T', 'U', 'V', 'W', 'X', 'Y'
	    } };

	// 
	// encode(<string>)	-- encode the supplied sequence of data in the domain (0,32] to base-32 
	// encode(<iter>,<iter>)-- encode the supplied std::string of (0,32] symbols in-place to base-32
	// 
	template < typename iter>
        iter			encode(
				    iter	begin,
				    iter	end )
	{
	    for ( iter i = begin; i != end; ++i ) {
		if ( *i >= 0 && size_t( *i ) < chrs.size() )
		    *i			= chrs[*i];
		else
		    throw std::runtime_error( "ezpwd::base32::encode: invalid symbol presented" );
	    }
	    return end;
	}

	inline
	std::string	       &encode(
				    std::string	       &symbols )
	{
	    encode( symbols.begin(), symbols.end() );
	    return symbols;
	}

	// 
	// decode(<iter>,<iter>)-- decode base-32 symbols in-place, collapsing spaces.
	// decode(<string>)	-- decode base-32 symbols in supplied std::string, collapsing spaces, in-place.
	// 
	//     If erasure vector supplied, marks invalid symbols as erasures; otherwise, throws
	// exception.  Ignores whitespace.  Will return an iterator to just after the last output
	// symbol used in the provided range (eg. to shorten the ), leaving any remaining symbols
	// unchanged.  The <string> version returns the same string reference passed in.
	// 
	// NOTE: will quite likely return an iterator before the supplied 'end', indicating
	// that the output has been truncated (shortened), due to collapsing spaces!
	// 
	template < typename iter >
	iter			decode(
				    iter		begin,
				    iter		end,
				    std::vector<int>   *erasure = 0 )
	{
	    if ( erasure )
		erasure->clear();
	    iter		i, o;
	    for ( i = begin, o = begin; i != end; ++i ) {
		if ( ::isspace( *i ))
		    continue;
		if ( ::islower( *i ))
		    *i	        = ::toupper( *i );
		switch ( *i ) {
		case 'Z': *i = '2'; break;
		case 'O': *i = '0'; break;
		case 'S': *i = '5'; break;
		case 'I': *i = '1'; break;
		}
		auto 		chri	= std::search( chrs.begin(), chrs.end(), i, i+1 );
		if ( chri == chrs.end() ) {
		    // Invalid symbol.  Mark as erasure?  Or throw.
		    if ( erasure ) {
			erasure->push_back( o - begin ); // index of offending // symbol in dest
			chri		= chrs.begin();
		    } else {
			throw std::runtime_error( "ezpwd::base32::decode: invalid symbol presented" );
		    }
		}
		*o++			= chri - chrs.begin();
	    }
	    return o;
	}

	inline
	std::string	       &decode(
				    std::string	       &symbols,
				    std::vector<int>   *erasure = 0 )
	{
	    auto		last	= decode( symbols.begin(), symbols.end(), erasure );
	    if ( last != symbols.end() )
		symbols.resize( last - symbols.begin() ); // eliminated some whitespace
	    return symbols;
	}

    } // namespace ezpwd::base32

    template < size_t P=1, size_t L=9 >			// 1 parity + 9 location symbols
    class ezcod {
    public:
	double			latitude;		// [-90,+90] angle, degrees
	double			latitude_error;		// total error bar, in meters
	double			longitude;		// [-180,180]
	double			longitude_error;	// total error bar, in meters
	double			accuracy;		// linear accuracy radius, in meters

	static const uint32_t	lat_parts = 1 << 22;	// [ -90,90 ] / 4,194,304 parts
	static const uint32_t	lon_parts = 1 << 23;	// [-180,180] / 8,388,608 parts

	typedef ezpwd::array< std::pair<size_t, size_t>, 12>
				bits_t;
	static const bits_t	bits;

	static RS_31( 31-P )	rscodec;

				ezcod(
				    double	_lat	= 0,
				    double	_lon	= 0 )
				    : latitude( _lat )
				    , latitude_error( 0 )
				    , longitude( _lon )
				    , longitude_error( 0 )
				    , accuracy( 0 )
	{
	    if ( P < 1 )
		throw std::runtime_error( "ezpwd::ezcod:: At least one parity symbol must be specified" );
	    if ( L < 1 || L > bits.max_size() )
		throw std::runtime_error( std::string( "ezpwd::ezcod:: Only 1-" ) + std::to_string( bits.max_size() ) + " location symbol may be specified" );
	}
				ezcod(
				    const std::string  &str)
				    : ezcod()
	{
	    decode( str );
	}
	virtual		       ~ezcod()
	{
	    ;
	}

	std::ostream	       &output( std::ostream &lhs )
	    const
	{
	    std::streamsize	prec	= lhs.precision();
	    std::ios_base::fmtflags
				flg	= lhs.flags();
	    lhs.precision( 10 );
	    bool		km	= accuracy > 1000;	
	    lhs << std::showpos << std::fixed << std::setprecision( 10 ) << std::setw( 15 ) << latitude << ", "
		<< std::showpos << std::fixed << std::setprecision( 10 ) << std::setw( 15 ) << longitude
		<< std::noshowpos << std::fixed << std::setprecision( 1 ) 
		<< " +/-" << ( km ? accuracy / 1000 : accuracy ) << ( km ? "km" : "m" )
		<< " == " << encode();
	    lhs.precision( prec );
	    lhs.flags( flg );
	    return lhs;
	}

	std::string		encode()
	    const
	{
	    // Convert lat/lon into a fraction of number of parts assigned to each
	    double		lat_frac= ( latitude +  90 ) / 180;
	    if ( lat_frac < 0 || lat_frac > 1 )
		throw std::runtime_error( "ezpwd::ezcod::encode: Latitude not in range [-90,90]" );
	    double		lon_frac= ( longitude + 180 ) / 360;
	    if ( lon_frac < 0 || lon_frac > 1 )
		throw std::runtime_error( "ezpwd::ezcod::encode: Longitude not in range [-180,180]" );

	    // Compute the integer number of lat/lon parts represented by each coordinate.
	    // Truncate to the range [0,..._parts), eg. Latitude 90 --> 89.999...
	    uint32_t		lat_rem	= std::min( lat_parts-1, uint32_t( lat_parts * lat_frac ));
	    uint32_t		lon_rem	= std::min( lon_parts-1, uint32_t( lon_parts * lon_frac ));

	    // Initial loop condition; lat/lon multiplier is left at the base multiplier of the
	    // previous loop.
	    unsigned int	lat_mult= lat_parts;
	    unsigned int	lon_mult= lon_parts;

	    std::string		res;
	    res.reserve( L+P+4 );
	    for ( auto &b : bits ) {
		size_t		lat_bits= b.first;
		size_t		lon_bits= b.second;

		// Each set of bits represents the number of times the current multiplier (after
		// division by the number of bits we're outputting) would go into the remainder.
		// Eg. If _mult was 1024, and _rem is 123 and _bits is 3, we're going to put out
		// the next 3 bits of the value 199.  The last value ended removing all multiples of 
		// 1024.  So, we first get the new multiplier: 1024 >> 3 == 128.  So, we're
		// indicating, as a 3-bit value, how many multiples of 128 there are in the value
		// 199: 199 / 128 == 1, so the 3-bit value we output is 001
		lat_mult       	      >>= lat_bits;
		uint32_t	lat_val	= lat_rem / lat_mult;
		lat_rem		       -= lat_val * lat_mult;

		lon_mult       	      >>= lon_bits;
		uint32_t	lon_val	= lon_rem / lon_mult;
		lon_rem		       -= lon_val * lon_mult;
		char		c	= char( ( lat_val << lon_bits ) | lon_val );
		res		       += c;
	    }

	    // Add the R-S parity symbols and base-32 encode
	    rscodec.encode( res );
	    ezpwd::base32::encode( res );
	    res.insert( 3,  1, ' ' );
	    res.insert( 7,  1, ' ' );
	    res.insert( 11, 1, ' ' );
	    
	    return res;
	}
	
	// 
	// validate(<string>)	-- remove base-32 encoding, validate and remove parity, returning confidence
	// decode(<string>)	-- attempt to decode a lat/lon, returning the confidence percentage
	// 
	//     If data but no parity symbols are supplied, no error checking is performed, and the
	// confidence returned will be 0%.  No erasures within the supplied data are allowed (as
	// there is no capacity to correct them), and an exception will be thrown.
	// 
	//     If parity is supplied, then erasures are allowed.  So long as the total number of
	// erasures is <= the supplied parity symbols, then the decode will proceed (using the
	// parity symbols to fill in the erasures), and the returned confidence will reflect the
	// amount of unused parity capacity.  Each erasure consumes one parity symbol to repair.
	//
	int			validate( std::string &dec )
	{
	    int			confidence = 0; // if no R-S parity provided
	    // Extract base-32, skipping whitespace, and marking invalid symbols as erasures.
	    std::vector<int>	erasure;
	    base32::decode( dec, &erasure );
	    if ( dec.size() > L || erasure.size() > 0 ) {
		// Some R-S parity symbol(s) were provided (or erasures were marked).  See if we can
		// successfully decode/correct, or (at least) use one parity symbol as a check
		// character.  If we identify more erasures than R-S parity, we must fail; we can't
		// recover the data.  This will of course be the case if we have *any* erasures in
		// the data, and no parity.
		size_t		parity	= 0;
		if ( dec.size() > L )
		    parity		= dec.size() - L;
		while ( dec.size() < L + P ) {
		    erasure.push_back( dec.size() );
		    dec.resize( dec.size() + 1 );
		}
		if ( erasure.size() > parity ) {
		    // We cannot do R-S decoding; not enough parity.  If exactly one parity symbol
		    // was provided, and all erasures were due the missing remaining parity symbols,
		    // we can use the existing parity symbol(s) as "check character(s)", by simply
		    // re-encoding the supplied non-parity data, and see if the generated parity
		    // symbol(s) match the supplied parity.  This has basically the same strength as
		    // the 10:10 code's check character.
		    if ( parity + erasure.size() == P ) {
			std::string chk( dec.begin(), dec.begin() + L );
			rscodec.encode( chk );
			if ( dec[L] != chk[L] )
			    throw std::runtime_error( "ezpwd::ezcod::decode: Error correction failed; check character mismatch" );
			// Check character(s) matched; erasure.size()/P of confidence gone
			confidence	= ezpwd::strength<P>( erasure.size(), erasure, erasure );
		    } else
			throw std::runtime_error( "ezpwd::ezcod::decode: Error correction failed; too many erasures" );
		} else {
		    // We can try R-S decoding; we have (at least) enough parity to try to recover
		    // missing symbol(s).
		    std::vector<int>position;
		    int		corrects= rscodec.decode( dec, erasure, &position );
		    if ( corrects < 0 )
			throw std::runtime_error( "ezpwd::ezcod::decode: Error correction failed; R-S decode failed" );
		    // Compute confidence, from spare parity capacity.  Since R-S decode will not
		    // return the position of erasures that turn out (by accident) to be correct,
		    // but they have consumed parity capacity, we re-add them into the correction
		    // position vector.  If the R-S correction reports more corrections than the
		    // parity can possibly have handled correctly, (eg. 2 reported erasures and an
		    // unexpected error), then the decode is almost certainly incorrect; fail.
		    confidence		= ezpwd::strength<P>( corrects, erasure, position );
		    if ( confidence < 0 )
			throw std::runtime_error( "ezpwd::ezcod::decode: Error correction failed; R-S decode overwhelmed" );
		}
		if ( dec.size() > L )
		    dec.resize( L ); // Discard any parity symbols
	    }
	    return confidence;
	}

	int			decode( const std::string &str )
	{
	    std::string		dec	= str;
	    int			confidence = validate( dec );

	    // Unpack the supplied location data; we'll take as much as we are given (up to the
	    // maximum 9 symbols supported, yielding <5m resolution).
	    uint32_t		lat_tot	= 0;
	    uint32_t		lon_tot	= 0;

	    uint32_t		lat_mult= lat_parts;
	    uint32_t		lon_mult= lon_parts;

	    auto		di	= dec.begin();
	    for ( auto &b : bits ) {
		size_t		lat_bits= b.first;
		size_t		lon_bits= b.second;
		if ( di == dec.end() )
		    break;
		char		c	= *di++;
		uint32_t	lat_val	= c >> lon_bits;
		uint32_t	lon_val	= c & (( 1 << lon_bits ) - 1 );

		lat_mult	      >>= lat_bits;
		lat_tot		       += lat_val * lat_mult;

		lon_mult	      >>= lon_bits;
		lon_tot		       += lon_val * lon_mult;
	    }

	    // Convert the sum of lat/lon parts back into degrees, and round the (truncated) value
	    // to the middle of the error square.  This allows us to minimize error even if we
	    // didn't have access to all of the origin symbols to decode.  The absolute error bar as
	    // a proportional factor [0,1) for lat/lon is at most the scale of the last parts
	    // multiplier used.  We'll use this later to compute the error in meters; for example,
	    // if the last value we added worked out to be worth units of 25m of the circumference,
	    // then we must now be within [0,25m) of the original point.
	    double		lat_err	= double( lat_mult ) / lat_parts;
	    double		lon_err	= double( lon_mult ) / lon_parts;

	    latitude			= 180 * ( double( lat_tot ) / lat_parts + lat_err / 2 ) -  90;
	    longitude			= 360 * ( double( lon_tot ) / lon_parts + lon_err / 2 ) - 180;

	    // Compute the resolution error (in m.) of the decoded lat/lon and compute the minimum
	    // accuracy -- the radius of the circle around the computed latitude/longitude, inside
	    // which the original latitude/longitude must have been.
	    // 
	    //            original   latitude error bar
	    //                 \     /
	    //                  o  - 
	    //                     |   longitude error bar
	    //                     |   /
	    //                  |--x--| 
	    //                     |\
	    //                     |  \
	    //                     -   computed
	    // 
	    // The maximum distance is the length of the diagonal of the error rectangle defined by
	    // 1/2 the latitude/longitude error bars.
	    // 
	    double		lon_circ= 1 * M_PI * 6371000;
	    double		lat_circ= 2 * M_PI * 6371000 * std::cos( latitude * M_PI / 180 );
	    latitude_error		= lat_err * lon_circ;
	    longitude_error		= lon_err * lat_circ;


	    accuracy			= sqrt(  latitude_error  / 2 * latitude_error  / 2
					       + longitude_error / 2 * longitude_error / 2 );

	    return confidence;
	}
    }; // class ezcod

    // 
    // ezcod::rscodec	-- Reed-Solomon parity codec
    // ezcod::bits	-- distribution of lat/lon precision in each code symbol
    // 
    //     Quickly establishes an extra bit of precision for Longitude, and then evenly distributes
    // future precision between lat/lon, always maintaining extra precision for Longitude.
    // 
    template < size_t P, size_t L >
    RS_31( 31-P )		ezcod<P,L>::rscodec;

    template < size_t P, size_t L >
    const typename 
    ezcod<P,L>::bits_t		ezcod<P,L>::bits = {
	{
	    //  bits per symbol            lat lon           
	    ezcod<P,L>::bits_t::value_type( 2,  3 ),
	    ezcod<P,L>::bits_t::value_type( 2,  3 ),
	    ezcod<P,L>::bits_t::value_type( 3,  2 ),
	    //                             --  --
	    //                              7   8
	    ezcod<P,L>::bits_t::value_type( 2,  3 ),
	    ezcod<P,L>::bits_t::value_type( 3,  2 ),
	    ezcod<P,L>::bits_t::value_type( 2,  3 ),
	    //                             --  --
	    //                             14  16
	    ezcod<P,L>::bits_t::value_type( 3,  2 ),
	    ezcod<P,L>::bits_t::value_type( 2,  3 ),
	    ezcod<P,L>::bits_t::value_type( 3,  2 ),
	    //                             --  --
	    //                             22  23
	    ezcod<P,L>::bits_t::value_type( 2,  3 ),
	    ezcod<P,L>::bits_t::value_type( 3,  2 ),
	    ezcod<P,L>::bits_t::value_type( 2,  3 ),
	    //                             --  --
	    //                             29  31
	}
    };
} // namespace ezpwd

template < size_t P, size_t L >
std::ostream		       &operator<<(
				    std::ostream	&lhs,
				    const ezpwd::ezcod<P,L>
				    			&rhs )
{
    return rhs.output( lhs );
}
#endif // _EZPWD_EZCOD
