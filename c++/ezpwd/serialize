/*
 * Ezpwd Reed-Solomon -- Reed-Solomon encoder / decoder library
 * 
 * Copyright (c) 2014, Hard Consulting Corporation.
 *
 * Ezpwd Reed-Solomon is free software: you can redistribute it and/or modify it under the terms of
 * the GNU General Public License as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.  See the LICENSE file at the top of the
 * source tree.  Ezpwd Reed-Solomon is also available under Commercial license.  The c++/ezpwd/rs
 * file is redistributed under the terms of the LGPL, regardless of the overall licensing terms.
 * 
 * Ezpwd Reed-Solomon is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
 * the GNU General Public License for more details.
 */
#ifndef _EZPWD_SERIALIZE
#define _EZPWD_SERIALIZE

#include <iterator>

#include "array_safe"


// 
// scatter -- 8-bit binary data into 5-bit (base32) and 6-bit (base64) chunks (optionally w/pad)
// gather -- collect up 5/6-bit binary data back into 8-bit characters (optionally w/pad)
// 
//     Scatters or gathers 8-bit binary character data to 5/6-bit symbols, suitable for base32/64
// encoding.
// 
// encode -- convert binary data to ASCII base32/64, in-place
// decode -- convert ASCII base32/64 to binary data, in-place
// 
//     Transforms iterable containers of char between ASCII symbols and binary data, always in-place.
// The decode may alter the size of the result (by ignoring whitespace).
// 
//     In general the ezpwd::base32/64 en/decoders are designed to produce easily human-usable
// encodings, and can ignore common whitespace characters and '-' to allow human-readable
// formatting.  The RFC4648 Standard base 32/64 and Crockford base32 encodings are also supported.
// 
namespace ezpwd {
    namespace serialize {

 	// 
	// encode -- iterate over range, encoding binary data to ASCII symbols using the table
	// 
	//     Items from iterator must be convertible to a table index (ie. not -'ve, and within
	// the table size N).  If the table contains 'ws' entries, they may optionally be ignored.
	// If the input symbol indexes outside the provided table (or an 'nv' entry), then an
	// exception will be thrown.
	// 
	enum chr_t {
	    pd		= -1,	// padding
	    nv		= -2,	// invalid
	    ws		= -3,	// whitespace
	};

	template < typename iter_t, size_t N >
	iter_t			encode(
				    iter_t		begin,
				    iter_t		end,
				    char		pad,		// optional pad char (for EOF)
				    const ezpwd::array<char,N>
						       &table )
	{
	    for ( iter_t i = begin; i != end; ++i ) {
		size_t		ti( *i );
		if ( ti < table.size() )
		    *i			= table[ti];
		else if ( *i == EOF and pad )
		    *i			= pad;
		else
		    throw std::runtime_error( "ezpwd::serialize::encode: invalid binary symbol presented" );
	    }
	    return end;
	}

	// 
	// decode -- iterate over range, encoding ASCII symbols to binary data using the table
	// 
	//     Items from iterator must be convertible to a table index (ie. not -'ve, and within
	// the table size, which is always 127).
	// 
	enum ws_use_t {
	    ws_invalid	= 0,
	    ws_ignore	= 1,
	};

	enum pd_use_t {
	    pd_invalid	= 0,
	    pd_ignore	= 1,
	    pd_keep	= 2,
	};

	template < typename iter_t >
	iter_t			decode(
				    iter_t		begin,
				    iter_t		end,
				    std::vector<int>   *erasure,	// Deem invalid symbols as erasures
				    std::vector<char>  *invalid,	//   and return the symbols
				    ws_use_t		ws_use,
				    pd_use_t		pd_use,
				    const ezpwd::array<char,127>
						       &table )
	{
	    if ( erasure )
		erasure->clear();
	    if ( invalid )
		invalid->clear();
	    iter_t		i, o;
	    for ( i = o = begin; i != end; ++i ) {
		size_t		ti( *i );
		char		c	= ti < table.size() ? table[ti] : char( nv );
		if ( ws == c ) {
		    if ( ws_ignore == ws_use ) {
			continue;
		    } else if ( ws_invalid == ws_use ) {
			c		= nv;
		    }
		}
		if ( pd == c ) {
		    if ( pd_ignore == pd_use ) {
			continue;
		    } else if ( pd_invalid == pd_use ) {
			c		= nv;
		    } else {
			c		= EOF;
		    }
		}
		if ( nv == c ) {
		    // Invalid symbol; optionally remember them.  Mark as erasure?  Or throw.
		    if ( invalid )
			invalid->push_back( *i );
		    if ( erasure ) {
			erasure->push_back( o - begin );// index of offending symbol in output
			c		= 0;		//   will be output w/ 0 value
		    } else {
			throw std::runtime_error( std::string( "ezpwd::serialize::decode: invalid ASCII symbol presented: " ) << int( *i ) << " '" << *i << "'") ;
		    }
		}
		*o++			= c;
	    }
	    return o;
	}
    } // namespace serialize

    // 
    // ezpwd::base32 -- transform individual characters between 5-bit binary and a base-32 encoding
    // 
    //     The char values [0,32) are mapped by base32::encode onto:
    // 
    //         0123456789ABCDEFGHJKLMNPQRTUVWXY
    // 
    // and base32::decode performs the inverse.  In addition to folding lower-case to upper-case,
    // the following mappings occur on decode:
    // 
    //    O -> 0
    //    Z -> 2
    //    S -> 5
    //    I -> 1
    // 
    //    Any characters encountered outside [0,32) by encode and outsside the above set by decode
    // raise an exception, unless an erasure vector is provided, in which case we supply a 0 value
    // and store the index of the invalid symbol in the vector.
    // 
    namespace base32 {
	using serialize::pd;
	using serialize::ws;
	using serialize::nv;
	using serialize::ws_use_t;
	using serialize::ws_ignore;
	using serialize::ws_invalid;
	using serialize::pd_use_t;
	using serialize::pd_ignore;
	using serialize::pd_invalid;
	using serialize::pd_keep;
	

	static const ezpwd::array<char,32> encoder_standard = { {  // RFC4648 Standard
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
		'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
		'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
		'Y', 'Z', '2', '3', '4', '5', '6', '7', 
	    } };
	static const ezpwd::array<char,32> encoder_crockford = { {
		'0', '1', '2', '3', '4', '5', '6', '7',
		'8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
		'G', 'H', 'J', 'K', 'M', 'N', 'P', 'Q',
		'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z',
	    } };
	static const ezpwd::array<char,32> encoder_ezpwd = { {
		'0', '1', '2', '3', '4', '5', '6', '7',
		'8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
		'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P',
		'Q', 'R', 'T', 'U', 'V', 'W', 'X', 'Y',
	    } };
	static const ezpwd::array<char,127> decoder_standard = { {
		nv, nv, nv, nv, nv, nv, nv, nv, nv, ws, ws, ws, ws, ws, nv, nv, // 9-13: <TAB>,<NL>,<VT>,<FF>,<CR>
		nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, //
		ws, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, //  !"#$%&`()*+,-./
		nv, nv, 26, 27, 28, 29, 30, 31, nv, nv, nv, nv, nv, pd, nv, nv, // 0123456789:;<=>?
		nv,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // @ABCDEFGHIJKLMNO  '=' is pad
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, nv, nv, nv, nv, nv, // PQRSTUVWXYZ[\]^_
		nv,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // `abcdefghijklmno
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, nv, nv, nv, nv,     // pqrstuvwxyz{|}~
	} };
	static const ezpwd::array<char,127> decoder_crockford = { {
		nv, nv, nv, nv, nv, nv, nv, nv, nv, ws, ws, ws, ws, ws, nv, nv, // 9-13: <TAB>,<NL>,<VT>,<FF>,<CR>
		nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, //
		ws, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, ws, nv, nv, //  !"#$%&`()*+,-./  '-' is whitespace
		 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, nv, nv, nv, pd, nv, nv, // 0123456789:;<=>?  '=' is pad
		nv, 10, 11, 12, 13, 14, 15, 16, 17,  1, 18, 19,  1, 20, 21,  0, // @ABCDEFGHIJKLMNO
		22, 23, 24, 25, 26, nv, 27, 28, 29, 30, 31, nv, nv, nv, nv, nv, // PQRSTUVWXYZ[\]^_
		nv, 10, 11, 12, 13, 14, 15, 16, 17,  1, 18, 19,  1, 20, 21,  0, // `abcdefghijklmno
		22, 23, 24, 25, 26, nv, 27, 28, 29, 30, 31, nv, nv, nv, nv,     // pqrstuvwxyz{|}~
	} };
	static const ezpwd::array<char,127> decoder_ezpwd = { {
		nv, nv, nv, nv, nv, nv, nv, nv, nv, ws, ws, ws, ws, ws, nv, nv, // 9-13: <TAB>,<NL>,<VT>,<FF>,<CR>
		nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, //
		ws, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, ws, nv, nv, //  !"#$%&`()*+,-./  '-' is whitespace
		 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, nv, nv, nv, pd, nv, nv, // 0123456789:;<=>?  '=' is pad
		nv, 10, 11, 12, 13, 14, 15, 16, 17,  1, 18, 19, 20, 21, 22,  0, // @ABCDEFGHIJKLMNO
		23, 24, 25,  5, 26, 27, 28, 29, 30, 31,  2, nv, nv, nv, nv, nv, // PQRSTUVWXYZ[\]^_
		nv, 10, 11, 12, 13, 14, 15, 16, 17,  1, 18, 19, 20, 21, 22,  0, // `abcdefghijklmno
		23, 24, 25,  5, 26, 27, 28, 29, 30, 31,  2, nv, nv, nv, nv,     // pqrstuvwxyz{|}~
	} };

	// 
	// base32::encode(<string>)	-- encode the supplied sequence of data in the domain (0,32] to base-32 
	// base32::encode(<iter>,<iter>)-- encode the supplied std::string of (0,32] symbols in-place to base-32
	// 
	//     If a non-zero 'pad' character is supplied, then the -1 (EOF) character value will be
	// allowed (normally occurring only at the end of the input range), and a 'pad' will be
	// emitted for each one.
	// 
	template < typename iter_t >
        iter_t			encode(
				    iter_t		begin,
				    iter_t		end,
				    char		pad	= 0, // '=' for standards-compliance
				    const ezpwd::array<char,32>
						       &table	= base32::encoder_ezpwd )
	{
	    return serialize::encode( begin, end, pad, table );
	}

	inline
	std::string	       &encode(
				    std::string	       &symbols,
				    char		pad	= 0, // '=' for standards-compliance
				    const ezpwd::array<char,32>
						       &table	= base32::encoder_ezpwd )
	{
	    base32::encode( symbols.begin(), symbols.end(), pad, table );
	    return symbols;
	}

	// 
	// base32::decode(<iter>,<iter>)-- decode base-32 symbols in-place, collapsing spaces.
	// base32::decode(<string>)	-- decode base-32 symbols in supplied std::string, collapsing spaces, in-place.
	// 
	//     If erasure vector supplied, marks invalid symbols as erasures; otherwise, throws
	// exception.  Ignores whitespace.  Will return an iterator to just after the last output
	// symbol used in the provided range (eg. to shorten the container, if desired), leaving any
	// remaining symbols unchanged.  The <string> version returns the same string reference
	// passed in (shortened, if spaces/padding ignored).
	// 
	//     If an invalid vector is supplied, we'll also return the offending input symbol(s); if
	// an exception is raised (no erasure vector supplied), only one symbol will be in invalid.
	// 
	// NOTE: will quite likely return an iterator before the supplied 'end', indicating that the
	// output has been truncated (shortened), due to collapsing spaces!
	// 
	template < typename iter_t >
	iter_t			decode(
				    iter_t		begin,
				    iter_t		end,
				    ws_use_t		ws_use	= ws_ignore,
				    pd_use_t		pd_use	= pd_keep,
				    const ezpwd::array<char,127>
						       &table	= base32::decoder_ezpwd )
	{
	    return serialize::decode( begin, end, 0, 0, ws_use, pd_use, table );
	}

	template < typename iter_t >
	iter_t			decode(
				    iter_t		begin,
				    iter_t		end,
				    std::vector<int>   *erasure,	// Deem invalid symbols as erasures
				    std::vector<char>  *invalid	= 0,	//   and return the symbols
				    ws_use_t		ws_use	= ws_ignore,
				    pd_use_t		pd_use	= pd_keep,
				    const ezpwd::array<char,127>
						       &table	= base32::decoder_ezpwd )
	{
	    return serialize::decode( begin, end, erasure, invalid, ws_use, pd_use, table );
	}

	inline
	std::string	       &decode(
				    std::string	       &symbols,
				    std::vector<int>   *erasure = 0,
				    std::vector<char>  *invalid	= 0,
				    ws_use_t		ws_use	= ws_ignore,
				    pd_use_t		pd_use	= pd_keep,
				    const ezpwd::array<char,127>
						       &table	= base32::decoder_ezpwd )
	{
	    auto		last	= base32::decode( symbols.begin(), symbols.end(), erasure, invalid,
						  ws_use, pd_use, table );
	    if ( last != symbols.end() )
		symbols.resize( last - symbols.begin() ); // eliminated some whitespace
	    return symbols;
	}

	// 
	// base32::scatter -- distribute a range of input bytes to an output iterator in 5-bit chunks
	// 
	//     Separate implementation are provided, for random-access iterators (with fewer
	// comparisons necessary) and for all other forward iterators.
	// 
	template < typename I, typename O, typename iterator_tag >
	O			scatter(
					I		beg,
					I		end,
					O 		out,
					bool		pad,
					iterator_tag )
        {
#if defined( DEBUG ) && DEBUG >= 2
	    std::cout << "scatter -- generic" << std::endl;
#endif
            while ( beg != end ) {
                int			c0	= *beg++;
                *out++				= char((c0 & 0xff) >> 3);

                if ( beg == end ) {
                    *out++			= char((c0 & 0x07) << 2);
		    if ( pad ) {
			*out++			= EOF;
			*out++			= EOF;
			*out++			= EOF;
			*out++			= EOF;
			*out++			= EOF;
			*out++			= EOF;
		    }
		    return out;
                }

                int			c1	= *beg++;
                *out++				= char((c0 & 0x07) << 2 | (c1 & 0xff) >> 6);
                *out++				= char((c1 & 0x3f) >> 1);

                if ( beg == end ) {
                    *out++			= char((c1 & 0x01) << 4);
		    if ( pad ) {
			*out++			= EOF;
			*out++			= EOF;
			*out++			= EOF;
			*out++			= EOF;
		    }
		    return out;
                }

                int			c2	= *beg++;
                *out++				= char((c1 & 0x01) << 4 | (c2 & 0xff) >> 4);

                if ( beg == end ) {
                    *out++			= char((c2 & 0x0f) << 1);
		    if ( pad ) {
			*out++			= EOF;
			*out++			= EOF;
			*out++			= EOF;
		    }
		    return out;
                }

                int			c3	= *beg++;
                *out++				= char((c2 & 0x0f) << 1 | (c3 & 0xff) >> 7);
                *out++				= char((c3 & 0x7f) >> 2);

                if ( beg == end ) {
                    *out++			= char((c3 & 0x03) << 3);
		    if ( pad ) {
			*out++			= EOF;
		    }
		    return out;
                }

                int			 c4	= *beg++;
                *out++				= char((c3 & 0x03) << 3 | (c4 & 0xff) >> 5);
                *out++				= char((c4 & 0x1f));
            }

            return out;
        }

	template < typename I, typename O >
	O			scatter(
					I		beg,
					I		end,
					O 		out,
					bool		pad,
					std::random_access_iterator_tag )
	{
#if defined( DEBUG ) && DEBUG >= 2
	    std::cout << "scatter -- random" << std::endl;
#endif
	    while ( end - beg >= 5 ) {
                int 			c0 	= *beg++;
                *out++ 				= char((c0 & 0xff) >> 3);
                int			c1	= *beg++;
                *out++				= char((c0 & 0x07) << 2 | (c1 & 0xff) >> 6);
                *out++				= char((c1 & 0x3f) >> 1);
                int			c2	= *beg++;
                *out++				= char((c1 & 0x01) << 4 | (c2 & 0xff) >> 4);
                int			c3	= *beg++;
                *out++				= char((c2 & 0x0f) << 1 | (c3 & 0xff) >> 7);
                *out++				= char((c3 & 0x7f) >> 2);
                int			c4	= *beg++;
                *out++				= char((c3 & 0x03) << 3 | (c4 & 0xff) >> 5);
                *out++				= char((c4 & 0x1f));
            }

            switch ( end - beg ) {
            case 4: {
                int			c0	= *beg++;
                *out++				= char((c0 & 0xff) >> 3);
                int			c1	= *beg++;
                *out++				= char((c0 & 0x07) << 2 | (c1 & 0xff) >> 6);
                *out++				= char((c1 & 0x3f) >> 1);
                int			c2	= *beg++;
                *out++				= char((c1 & 0x01) << 4 | (c2 & 0xff) >> 4);
                int			c3	= *beg++;
                *out++				= char((c2 & 0x0f) << 1 | (c3 & 0xff) >> 7);
                *out++				= char((c3 & 0x7f) >> 2);
                *out++				= char((c3 & 0x03) << 3);
		if ( pad ) {
		    *out++			= EOF;
		}
		return out;
            }
            case 3: {
                int			c0	= *beg++;
                *out++				= char((c0 & 0xff) >> 3);
                int			c1	= *beg++;
                *out++				= char((c0 & 0x07) << 2 | (c1 & 0xff) >> 6);
                *out++				= char((c1 & 0x3f) >> 1);
                int			c2	= *beg++;
                *out++				= char((c1 & 0x01) << 4 | (c2 & 0xff) >> 4);
                *out++				= char((c2 & 0x0f) << 1);
		if ( pad ) {
		    *out++			= EOF;
		    *out++			= EOF;
		    *out++			= EOF;
		}
		return out;
            }
            case 2: {
                int			c0	= *beg++;
                *out++				= char((c0 & 0xff) >> 3);
		int			c1	= *beg++;
                *out++				= char((c0 & 0x07) << 2 | (c1 & 0xff) >> 6);
                *out++				= char((c1 & 0x3f) >> 1);
                *out++				= char((c1 & 0x01) << 4);
		if ( pad ) {
		    *out++			= EOF;
		    *out++			= EOF;
		    *out++			= EOF;
		    *out++			= EOF;
		}
		return out;
            }
            case 1: {
                int			c0	= *beg++;
                *out++				= char((c0 & 0xff) >> 3);
                *out++				= char((c0 & 0x07) << 2);
		if ( pad ) {
		    *out++			= EOF;
		    *out++			= EOF;
		    *out++			= EOF;
		    *out++			= EOF;
		    *out++			= EOF;
		    *out++			= EOF;
		}
		return out;
            }
            default:
		return out;
            }
        }

	template < typename I, typename O >
	O			scatter(
					I		beg,
					I		end,
					O 		out,
					bool		pad )
	{
	    return scatter( beg, end, out, pad, typename std::iterator_traits<I>::iterator_category() );
	}
	

	// 
	// base32::gather -- collect 5-bit chunks into 8-bit characters
	// 
	//     If underflow occurs (not enough data collected to output complete last char), then an
	// exception will be raised.  However, if 'pad' is set, then output will automatically be
	// padded, discarding any un-emitted data remaining in previous 5-bit base32 symbols.
	// 
	//     For correct base32 data produced by 'scatter', this will allow 'gather' to always
	// produce the identical output as was originally provided to 'scatter'.  However, if simply
	// truncated base32 input is provided (eg. only 1, 3 or 5 symbols of an 8-symbol 40-bit
	// base32 group), then the final 8-bit symbol from the original data will be missing.
	// 
	// 
	template < typename I >
	static
	int				gather_next( I &beg, I end, bool pad, int previous )
	{
	    if ( beg == end ) {
		if ( not pad )
		    throw std::logic_error("base32 gather error; insufficient data");
		// automatically pad; return nv on underflow while unemitted data remains, finally pd
		return previous >= 0 ? nv : pd;
	    }
	    int				c	= *beg++;
	    if ( previous < 0 and c >= 0 )
		throw std::logic_error( "base32 gather error; data following padding" );
	    if ( c >= 32 or c < pd )
		throw std::logic_error( "base32 gather error; symbol value beyond 5 bits" );
	    return c;
	}

	template < typename I, typename O >
	O				gather(
					    I			beg,
					    I			end,
					    O			out,
					    bool		pad	= false )
	{
	    while ( beg != end ) {
                int			c0	= gather_next( beg, end, pad, 0 );
		int			c1	= gather_next( beg, end, pad, c0 );
		if ( c0 >= 0 and c1 >= 0 )
		    *out++			= ( ((c0 < 0 ? 0 : c0 ) << 3)
						   | (c1 < 0 ? 0 : c1 ) >> 2 );
                int			c2	= gather_next( beg, end, pad, c1 );
                int			c3 	= gather_next( beg, end, pad, c2 );
		if ( c1 >= 0 and c2 >= 0 and c3 >= 0 )
		    *out++ 			= ( ((c1 < 0 ? 0 : c1) & 0x03) << 6 
						   | (c2 < 0 ? 0 : c2) << 1
						   | (c3 < 0 ? 0 : c3) >> 4 );
                int			c4	= gather_next( beg, end, pad, c3 );
		if ( c3 >= 0 and c4 >= 0 )
		    *out++			= ( ((c3 < 0 ? 0 : c3) & 0x0f) << 4
						   | (c4 < 0 ? 0 : c4) >> 1 );
                int			c5	= gather_next( beg, end, pad, c4 );
                int			c6	= gather_next( beg, end, pad, c5 );
		if ( c4 >=0 and c5 >= 0 and c6 >= 0 )
		    *out++			= ( ((c4 < 0 ? 0 : c4) & 0x01) << 7 
						   | (c5 < 0 ? 0 : c5) << 2
						   | (c6 < 0 ? 0 : c6) >> 3 );
                int			c7	= gather_next( beg, end, pad, c6 );
		if ( c6 >= 0 and c7 >= 0 )
		    *out++			= ( ((c6 < 0 ? 0 : c6 ) & 0x07) << 5 
						   | (c7 < 0 ? 0 : c7 ));
	    }
	    return out;
	}
    } // namespace ezpwd::base32

    // 
    // ezpwd::base64 -- transform individual characters between 6-bit binary and base64
    // 
    //     The char values [0,64) are mapped by base64::encode onto either the
    // standard or ezpwd (url-safe) tables:
    // 
    //         ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
    //         ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_
    // 
    // and base64::decode performs the inverse (handles both standard and url-safe encodings).
    // 
    //    Any characters encountered outside [0,64) by encode and outside the above set
    // by decode raise an exception.
    // 
    namespace base64 {
	using serialize::pd;
	using serialize::ws;
	using serialize::nv;
	using serialize::ws_use_t;
	using serialize::ws_ignore;
	using serialize::ws_invalid;
	using serialize::pd_use_t;
	using serialize::pd_ignore;
	using serialize::pd_invalid;
	using serialize::pd_keep;

	static ezpwd::array<char,64> encoder_standard = { { // RFC4846 Standard
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
		'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
		'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
		'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
		'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
		'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
		'w', 'x', 'y', 'z', '0', '1', '2', '3',
		'4', '5', '6', '7', '8', '9', '+', '/',
	} };
	static ezpwd::array<char,64> encoder_standard_url = { { // RFC4846 Standard (URL safe)
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
		'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
		'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
		'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
		'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
		'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
		'w', 'x', 'y', 'z', '0', '1', '2', '3',
		'4', '5', '6', '7', '8', '9', '-', '_', 
	} };
	static ezpwd::array<char,64> encoder_ezpwd = { { // '+' and '.' are URL safe, and we treat '-' as whitespace
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
		'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
		'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
		'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
		'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
		'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
		'w', 'x', 'y', 'z', '0', '1', '2', '3',
		'4', '5', '6', '7', '8', '9', '+', '.', 
	} };
	static ezpwd::array<char,127> decoder_standard = { {
		nv, nv, nv, nv, nv, nv, nv, nv, nv, ws, ws, ws, ws, ws, nv, nv, // 9-13: <TAB>,<NL>,<VT>,<FF>,<CR>
		nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, //
		ws, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, 62, nv, nv, nv, 63, //  !"#$%&`()*+,-./
		52, 53, 54, 55, 56, 57, 58, 59, 60, 61, nv, nv, nv, pd, nv, nv, // 0123456789:;<=>?  '=' is pad
		nv,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // @ABCDEFGHIJKLMNO
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, nv, nv, nv, nv, nv, // PQRSTUVWXYZ[\]^_
		nv, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, // `abcdefghijklmno
		41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, nv, nv, nv, nv,     // pqrstuvwxyz{|}~
	} };
	static ezpwd::array<char,127> decoder_standard_url = { {
		nv, nv, nv, nv, nv, nv, nv, nv, nv, ws, ws, ws, ws, ws, nv, nv, // 9-13: <TAB>,<NL>,<VT>,<FF>,<CR>
		nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, //
		ws, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, 62, nv, nv, //  !"#$%&`()*+,-./
		52, 53, 54, 55, 56, 57, 58, 59, 60, 61, nv, nv, nv, pd, nv, nv, // 0123456789:;<=>?  '=' is pad
		nv,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // @ABCDEFGHIJKLMNO
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, nv, nv, nv, nv, 63, // PQRSTUVWXYZ[\]^_
		nv, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, // `abcdefghijklmno
		41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, nv, nv, nv, nv,     // pqrstuvwxyz{|}~
	} };
	static ezpwd::array<char,127> decoder_ezpwd = { {
		nv, nv, nv, nv, nv, nv, nv, nv, nv, ws, ws, ws, ws, ws, nv, nv, // 9-13: <TAB>,<NL>,<VT>,<FF>,<CR>
		nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, //
		ws, nv, nv, nv, nv, nv, nv, nv, nv, nv, nv, 62, nv, ws, 63, nv, //  !"#$%&`()*+,-./  '-' is whitespace
		52, 53, 54, 55, 56, 57, 58, 59, 60, 61, nv, nv, nv, pd, nv, nv, // 0123456789:;<=>?  '=' is pad
		nv,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // @ABCDEFGHIJKLMNO
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, nv, nv, nv, nv, 63, // PQRSTUVWXYZ[\]^_
		nv, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, // `abcdefghijklmno
		41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, nv, nv, nv, nv,     // pqrstuvwxyz{|}~
	} };

	// 
	// base64::encode(<string>)	-- encode the supplied sequence of data in the domain (0,64] to base-64
	// base64::encode(<iter>,<iter>)-- encode the supplied std::string of (0,64] symbols in-place to base-64
	// 
	template < typename iter_t >
        iter_t			encode(
				    iter_t		begin,
				    iter_t		end,
				    char		pad	= 0, // '=' for standards-compliance
				    const ezpwd::array<char,64>
						       &table	= base64::encoder_ezpwd )
	{
	    return serialize::encode( begin, end, pad, table );
	}

	inline
	std::string	       &encode(
				    std::string	       &symbols,
				    char		pad	= 0, // '=' for standards-compliance
				    const ezpwd::array<char,64>
						       &table	= base64::encoder_ezpwd )
	{
	    base64::encode( symbols.begin(), symbols.end(), pad, table );
	    return symbols;
	}

	// 
	// decode(<iter>,<iter>)-- decode base-32 symbols in-place, collapsing spaces.
	// decode(<string>)	-- decode base-32 symbols in supplied std::string, collapsing spaces, in-place.
	// 
	template < typename iter_t >
	iter_t			decode(
				    iter_t		begin,
				    iter_t		end,
				    ws_use_t		ws_use	= ws_ignore,
				    pd_use_t		pd_use	= pd_keep,
				    const ezpwd::array<char,127>
						       &table	= base64::decoder_ezpwd )
	{
	    return serialize::decode( begin, end, 0, 0, ws_use, pd_use, table );
	}

	template < typename iter_t >
	iter_t			decode(
				    iter_t		begin,
				    iter_t		end,
				    std::vector<int>   *erasure,	// Deem invalid symbols as erasures
				    std::vector<char>  *invalid	= 0,	//   and return the symbols
				    ws_use_t		ws_use	= ws_ignore,
				    pd_use_t		pd_use	= pd_keep,
				    const ezpwd::array<char,127>
						       &table	= base64::decoder_ezpwd )
	{
	    return serialize::decode( begin, end, erasure, invalid, ws_use, pd_use, table );
	}

	inline
	std::string	       &decode(
				    std::string	       &symbols,
				    std::vector<int>   *erasure = 0,
				    std::vector<char>  *invalid	= 0,
				    ws_use_t		ws_use	= ws_ignore,
				    pd_use_t		pd_use	= pd_keep,
				    const ezpwd::array<char,127>
						       &table	= base64::decoder_ezpwd )
	{
	    auto		last	= base64::decode( symbols.begin(), symbols.end(), erasure, invalid,
						  ws_use, pd_use, table );
	    if ( last != symbols.end() )
		symbols.resize( last - symbols.begin() ); // eliminated some whitespace
	    return symbols;
	}

    } // namespace ezpwd::base64
} // namespace ezpwd

#endif // _EZPWD_SERIALIZE
