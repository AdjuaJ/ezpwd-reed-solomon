#ifndef _EZPWD_ARRAY
#define _EZPWD_ARRAY

namespace ezpwd {

#if defined( EZPWD_ARRAY_SAFE )
    // 
    // ezpwd::array -- a std::array replacement with optional bounds checking enabled
    // 
    //     Only enabled when EZPWD_ARRAY_SAFE is defined in the preprocessor
    // 
    template < typename T, std::size_t S >
    struct array
	: public std::array<T, S> {
	using typename std::array<T,S>::value_type;
	using typename std::array<T,S>::pointer;
	using typename std::array<T,S>::const_pointer;
	using typename std::array<T,S>::reference;
	using typename std::array<T,S>::const_reference;
	using typename std::array<T,S>::iterator;
	using typename std::array<T,S>::const_iterator;
	using typename std::array<T,S>::size_type;
	using typename std::array<T,S>::difference_type;
	using typename std::array<T,S>::reverse_iterator;
	using typename std::array<T,S>::const_reverse_iterator;

				array()
				    : std::array<T,S>() {;}

				array( const std::array<T,S> &rhs )
				    : std::array<T,S>( rhs ) {;}

				array( const std::array<T,S> &&rhs )
				    : std::array<T,S>( rhs ) {;}

	using std::array<T,S>::fill;
	using std::array<T,S>::swap;
	using std::array<T,S>::begin;
	using std::array<T,S>::end;
	using std::array<T,S>::rbegin;
	using std::array<T,S>::rend;
	using std::array<T,S>::cbegin;
	using std::array<T,S>::cend;
	using std::array<T,S>::crbegin;
	using std::array<T,S>::crend;
	using std::array<T,S>::size;
	using std::array<T,S>::max_size;
	using std::array<T,S>::empty;
	using std::array<T,S>::at;
	using std::array<T,S>::front;
	using std::array<T,S>::back;
	using std::array<T,S>::data;

	reference		operator[]( size_type i )
	{
	    return at( i );
	}

	constexpr
	const_reference		operator[]( size_type i )
	    const
	{
	    return at( i );
	}
    }; // struct ezpwd::array
#else
    using std::array; // ! EZPWD_ARRAY_SAFE: ezpwd::arrray is std::array
#endif
} // namespace ezpwd

#endif // _EZPWD_ARRAY
