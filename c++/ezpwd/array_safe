#ifndef _EZPWD_ARRAY
#define _EZPWD_ARRAY

#include <iterator>
#include <algorithm>
#include <cstddef>

#  if ! defined( EZPWD_ARRAY_SAFE )

#  include <array>

namespace ezpwd {
    //
    // ! EZPWD_ARRAY_SAFE: ezpwd::arrray is std::array
    //
    using std::array;
} // namespace ezpwd

#  else

namespace ezpwd {
    // 
    // ezpwd::array -- a std::array replacement with bounds checking enabled
    // 
    //     Only enabled when EZPWD_ARRAY_SAFE is defined in the preprocessor
    // 
    template < typename T, std::size_t S >
    struct array {
	
	typedef T		value_type;
	typedef value_type&     reference;
	typedef const value_type&const_reference;
	typedef value_type*     iterator;
	typedef const value_type*const_iterator;
	typedef value_type*     pointer;
	typedef const value_type*const_pointer;
	typedef size_t          size_type;
	typedef ptrdiff_t       difference_type;
	typedef std::reverse_iterator<iterator>
				reverse_iterator;
	typedef std::reverse_iterator<const_iterator>
				const_reverse_iterator;

	value_type		__elems_[ S ? S : 1 ];

	void			fill(
				    const value_type   &__u )
        {
	    std::fill_n( __elems_, S, __u );
	}
	void			swap(
				    array	       &__a ) 
        {
	    std::swap_ranges( __elems_, __elems_ + S, __a.__elems_ );
	}

	// iterators:
	iterator		begin()
	    noexcept
	{
	    return iterator( __elems_ );
	}
	const_iterator		begin()
	    const noexcept
	{
	    return const_iterator( __elems_ );
	}
	iterator		end()
	    noexcept
	{
	    return iterator( __elems_ + S );
	}
	const_iterator		end()
	    const noexcept
	{
	    return const_iterator( __elems_ + S );
	}
	reverse_iterator	rbegin()
	    noexcept
	{
	    return reverse_iterator( end() );
	}
	const_reverse_iterator	rbegin()
	    const noexcept
	{
	    return const_reverse_iterator( end() );
	}
	reverse_iterator	rend()
	    noexcept
	{
	    return reverse_iterator( begin() );
	}
	const_reverse_iterator	rend()
	    const noexcept
	{
	    return const_reverse_iterator( begin() );
	}
	const_iterator		cbegin()
	    const noexcept
	{
	    return begin();
	}
	const_iterator		cend()
	    const noexcept
	{
	    return end();
	}
	const_reverse_iterator	crbegin()
	    const noexcept
	{
	    return rbegin();
	}
	const_reverse_iterator	crend()
	    const noexcept
	{
	    return rend();
	}

	// capacity:
	constexpr size_type	size()
	    const noexcept
	{
	    return S;
	}
	constexpr size_type	max_size()
	    const noexcept
	{
	    return S;
	}
	constexpr bool		empty()
	    const noexcept
	{
	    return S == 0;
	}

	// element access: Always with bounds checking
	reference		at(
				    size_type		__n )
	{
	    return ( __n < S
		     ?  __elems_[__n]
		     : ( throw std::out_of_range( "array::at" ), __elems_[0] ));
	}
	constexpr
	const_reference		at(
				    size_type		__n )
	    const
	{
	    return ( __n < S
		     ?  __elems_[__n]
		     : ( throw std::out_of_range( "array::at" ), __elems_[0] ));
	}
	reference		operator[]( size_type i )
	{
	    return at( i );
	}
	constexpr
	const_reference		operator[]( size_type i )
	    const
	{
	    return at( i );
	}
	reference		front()
	{
	    return __elems_[0];
	}
	constexpr
	const_reference		front()
	    const
	{
	    return __elems_[0];
	}
	reference		back()
	{
	    return __elems_[ S ? S-1 : 0 ];
	}
	constexpr
	const_reference		back()
	    const
	{
	    return __elems_[ S ? S-1 : 0 ];
	}
	value_type	       *data()
	    noexcept
	{
	    return __elems_;
	}
	const value_type       *data()
	    const noexcept
	{
	    return __elems_;
	}
    }; // struct ezpwd::array
} // namespace ezpwd

template <class T, size_t S>
inline bool			operator==(
				    const ezpwd::array<T, S> &__x,
				    const ezpwd::array<T, S> &__y )
{
    return std::equal( __x.__elems_, __x.__elems_ + S, __y.__elems_ );
}

template <class T, size_t S>
inline bool			operator!=(
				    const ezpwd::array<T, S> &__x,
				    const ezpwd::array<T, S> &__y )
{
    return !(__x == __y);
}

template <class T, size_t S>
inline bool			operator<(
				    const ezpwd::array<T, S> &__x,
				    const ezpwd::array<T, S> &__y )
{
    return std::lexicographical_compare(__x.__elems_, __x.__elems_ + S, __y.__elems_, __y.__elems_ + S);
}

template <class T, size_t S>
inline bool			operator>(
				    const ezpwd::array<T, S> &__x,
				    const ezpwd::array<T, S> &__y )
{
    return __y < __x;
}

template <class T, size_t S>
inline bool			operator<=(
				    const ezpwd::array<T, S> &__x,
				    const ezpwd::array<T, S> &__y )
{
    return !(__y < __x);
}

template <class T, size_t S>
inline bool			operator>=(
				    const ezpwd::array<T, S> &__x,
				    const ezpwd::array<T, S> &__y )
{
    return !(__x < __y);
}

template <class T, size_t S>
inline void			swap(
				    const ezpwd::array<T, S> &__x,
				    const ezpwd::array<T, S> &__y )
{
    __x.swap(__y);
}

namespace std {
    template <typename T, size_t S>
    struct tuple_size<ezpwd::array<T, S> >
	: public integral_constant<size_t, S> {};

    template <size_t I, typename T, size_t S>
    struct tuple_element<I, ezpwd::array<T, S> >
    {
	static_assert( I < S, "index is out of bounds" );
	typedef T type;
    };
} // namespace std

template <size_t I, class T, size_t S>
inline constexpr T	       &get(
			            ezpwd::array<T, S> &__a )
    noexcept
{
    static_assert(I < S, "Index out of bounds in std::get<> (ezpwd::array)");
    return __a.__elems_[I];
}

template <size_t I, class T, size_t S>
inline constexpr const T       &get(
				    const ezpwd::array<T, S> &__a )
    noexcept
{
    static_assert(I < S, "Index out of bounds in std::get<> (const ezpwd::array)");
    return __a.__elems_[I];
}

template <size_t I, class T, size_t S>
inline  constexpr T	      &&get(
				    ezpwd::array<T, S> &&__a )
    noexcept
{
    static_assert(I < S, "Index out of bounds in std::get<> (ezpwd::array &&)");
    return std::move( __a.__elems_[I] );
}
#  endif // EZPWD_ARRAY_SAFE
#endif // _EZPWD_ARRAY
