#ifndef _EZPWD_HEX
#define _EZPWD_HEX

#include <iostream>
#include <iomanip>

// 
// ezpwd::hexify	-- hexify something that can be converted to an unsigned char
// ezpwd::hexout	-- hexify each element in the range (beg,end] 
// 
//     Optionally, limit each line length by setting the output ostream's width.
// 
// std::ostream << ezpwd::hexify( c )
// std::ostream << ezpwd::hexout( beg, end )
// std::ostream << std::vector<unsigend char>
// std::ostream << std::array<unsigend char, N>
// 
//     Output unprintable unsigned char data in hex, escape printable/space data.
//
namespace ezpwd {
    struct hexify {
	unsigned char		c;
	std::streamsize		w;
				hexify(
				    unsigned char	_c,
				    std::streamsize	_w	= 2 )
				    : c( _c )
				    , w( _w )
	{ ; }
				hexify(
				    char		_c,
				    std::streamsize	_w	= 2 )
				    : c( (unsigned char)_c )
				    , w( _w )
	{ ; }
    };
    struct hexstr {
	const std::string      &s;
				hexstr(
				    const std::string  &_s )
				    : s( _s )
	{ ; }
    };
} // namespace ezpwd

inline
std::ostream		       &operator<<(
				    std::ostream       &lhs,
				    const ezpwd::hexify&rhs )
{
    std::ios_base::fmtflags	flg	= lhs.flags();			// left, right, hex?
    
    lhs << std::setw( rhs.w );
    if ( isprint( rhs.c ) || isspace( rhs.c )) {
	switch ( char( rhs.c )) {
	case 0x00: lhs << "\\0";  break;		// NUL
	case 0x07: lhs << "\\a";  break;		// BEL
	case 0x08: lhs << "\\b";  break;		// BS
	case 0x1B: lhs << "\\e";  break;		// ESC
	case 0x09: lhs << "\\t";  break;		// HT
	case 0x0A: lhs << "\\n";  break;		// LF
	case 0x0B: lhs << "\\v";  break;		// VT
	case 0x0C: lhs << "\\f";  break;		// FF
	case 0x0D: lhs << "\\r";  break;		// CR
	case ' ':  lhs << "  ";   break;		// space
	case '\\': lhs << "\\\\"; break;		// '\'
	default:   lhs << char( rhs.c );		// any other printable character
	}
    } else {
	char			fill	= lhs.fill();
	lhs << std::setfill( '0' ) << std::hex << std::uppercase 
	    << (unsigned int)rhs.c
	    << std::setfill( fill ) << std::dec << std::nouppercase;
    }
    lhs.flags( flg );
    return lhs;
}

namespace ezpwd {
    template < typename iter_t >
    inline
    std::ostream	       &hexout(
				    std::ostream       &lhs,
				    const iter_t       &beg,
				    const iter_t       &end )
    {
	std::streamsize		wid	= lhs.width( 0 );
	int			col	= 0;
	for ( auto i = beg; i != end; ++i ) {
	    if ( wid && col == wid ) {
		lhs << std::endl;
		col			= 0;
	    }
	    lhs << hexify( *i );
	    ++col;
	}
	return lhs;
    }
} // namespace ezpwd

inline
std::ostream		       &operator<<(
				    std::ostream       &lhs,
				    const ezpwd::hexstr&rhs )
{
    return ezpwd::hexout( lhs, rhs.s.begin(), rhs.s.end() );
}

template < size_t S >
inline
std::ostream		       &operator<<(
				    std::ostream       &lhs,
				    const std::array<unsigned char,S>
						       &rhs )
{
    return ezpwd::hexout( lhs, rhs.begin(), rhs.end() );
}

inline
std::ostream		       &operator<<(
				    std::ostream       &lhs,
				    const std::vector<unsigned char>
						       &rhs )
{
    return ezpwd::hexout( lhs, rhs.begin(), rhs.end() );
}

// 
//    <ostream&> << pair<T,U>
//    <ostream&> << set<T>		-- sorted by T
//    <ostream&> << map<T,U>		-- sorted by T (key)
//    <ostream&> << vector<T>
// 
//     Handle output of various container types.
// 
//     Output pairs and sets of pairs, respecting specified widths (as appropriate).  For example
// a set of pairs of integeters 's', if output as "... << std::setw( 13 ) << s;", would yield:
// 
//	   (	1,    2) (    3,   4) ...
// 

template <class T, class U>
std::ostream		       &operator<<(
				    std::ostream       &lhs,
				    const std::pair<T,U> &rhs )
{
    std::streamsize		w	= std::max( std::streamsize( 0 ),
						    std::streamsize( lhs.width() - 3 ));
    lhs << std::setw( 0 )
	<< '('	<< std::setw(	  w / 2 ) << rhs.first 
	<< ','	<< std::setw( w - w / 2 ) << rhs.second 
	<< ')';
    return lhs;
}

template <class T>
std::ostream		       &operator<<(
				    std::ostream       &lhs,
				    const std::set<T>  &rhs )
{
    std::streamsize		w	= lhs.width();		// If width is set, use if for each item
    for ( typename std::set<T>::const_iterator
				si	= rhs.begin()
	      ; si		       != rhs.end()
	      ; ++si ) {
	if ( si != rhs.begin()) 
	    lhs << ' ';
	lhs << std::setw( w ) << *si;
    }
    lhs << std::setw( 0 );					// If container empty, must clear
    return lhs;
}

template <class T, class U>
std::ostream		       &operator<<(
				    std::ostream       &lhs,
				    const std::map<T,U>&rhs )
{
    std::streamsize		w	= lhs.width();		// If width is set, use if for each item
    std::vector<T>		key;
    for ( typename std::map<T,U>::const_iterator
				mi	= rhs.begin()
	      ; mi		       != rhs.end()
	      ; ++mi )
	key.push_back( mi->first );
    std::sort( key.begin(), key.end() );
    for ( typename std::vector<T>::const_iterator
				ki	= key.begin()
	      ; ki		       != key.end()
	      ; ++ki ) {
	if ( ki != key.begin()) 
	    lhs << ' ';
	lhs << std::setw( w ) << *rhs.find( *ki );
    }
    lhs << std::setw( 0 );					// If container empty, must clear
    return lhs;
}

template <class T>
std::ostream		       &operator<<(
				    std::ostream	   &lhs, 
				    const std::vector<T>   &rhs )
{
    for( size_t i = 0; i < rhs.size(); ++i ) {
	if ( i )
	    lhs << ", ";
	lhs << rhs[i];
    }

    return lhs;
}

#endif // _EZPWD_HEX
