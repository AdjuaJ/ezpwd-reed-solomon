# -*- coding: utf-8 -*-
#+TITLE: EZPWD Reed-Solomon Version 1.4.0

* Reed-Solomon Loss/Error Correction

  Error and erasure detection and correction for C++, Javascript and Python
  programs.  Based on Phil Karn's excellent implementation (as used by the Linux
  kernel), converted to C++.

  Several C++ and Javascript utilities implemented using Reed-Solomon are
  provided.

  The Javascript APIs are produced from the C++ implementation using
  =emscripten=, and are very performant.  All Javascript is available for
  inclusion in websites via MaxCDN.

** Performance

   The Reed-Solomon codec's performance is often a critical determinant in
   product performance, and often influences expensive decisions such as CPU
   selection for embedded applications.

   The =ezpwd::RS<...>= codec corrects data in-place to avoid unnecessary
   copying, using shared data tables between RS instances with compatible size,
   parity and Galois field parameters.  The use of C++ template parameters for
   size-related Reed Solomon parameters enables the compiler to emit optimal
   code for all internal table lookups, sometimes dramatically improving
   performance.

*** 25-75% Faster Than Competing Codecs

    EZPWD Reed Solomon performs R-S correction operations (using g++ on an Intel
    i7) about 75% faster faster than Phil Karn's general case code, and about
    25% faster than Phil's optimized code for 8-bit/CCSDS symbols.  It also
    tests at about 25% faster than the Shifra C++ Reed-Solomon library.  It
    appears that, for certain applications at least, EZPWD Reed-Solomon may be
    the fastest Open Source general-purpose C++ Reed-Solomon library presently
    available.

** Availability

   Source code is hosted at [[https://github.com/pjkundert/ezpwd-reed-solomon]].  It
   is heavily tested under both g++ and clang++, with full optimization enabled.

*** C++ Build Requires Header Source Only

    Carefully implemented as C++11 standard inline code, to require no C++
    object-code or library build procedure.  As a result, integration into
    existing C++ code-bases and build systems is extremely simple.

*** Javascript Hosted by MaxCDN

    Production minified Javascript is served by MaxCDN, using a URL like:
   [[ https://cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.4.0/js/ezpwd/ezcod.js]].

    For example, to use the EZCOD position encoding API in your website, add
    this at the end of your website template, before your application.js:
    #+BEGIN_SRC HTML
    <script
      src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.4.0/js/ezpwd/ezcod.js">
    </script>
    #+END_SRC

    Note the current <VERSION> number encoded in the URI as =.../v<VERSION>/...".

    Your application may permanently access any current or historical version of
    the EZPWD Reed-Solomon Javascript which has a Tag in the official Git repo,
    by encoding the <VERSION> number in the URL: 
    : //cdn.rawgit.com/.../v<VERSION>/...

*** Python Interface using Swig

    A high-performance Python 2/3 interface is provided, using [[http://www.swig.org/][Swig]] (requires at
    least Swig Version 3.0.5 for C++11 support).  Since the Python module is
    generated from the C++ interface, it must be generated and compiled using
    the appropriate target OS, Python and C++ compiler implementation.
    Therefore, there is no =pip install ezpwd_reed_solomon= available.

    To build the =ezpwd_reed_solomon= package, obtain the source from
    https://github.com/pjkundert/ezpwd-reed-solomon, and build with the version
    of Python you wish to support:
    : $ cd ezpwd-reed-solomon/swig/python
    : $ python setup.py install

    Presently, only =ezpwd_reed_solomon.ezcod= is available; see the [[EZCOD:
    Location Code API]] section for Python API details.

**** Swig 3.0.5+

     To install the Python API, you'll need a modern Swig.

     On Mac, use homebrew:
     : $ brew install swig
     
     On Linux Debian or Ubuntu Linux systems, you should be able to use
     something like this (other Linux variants should have similar package
     installation facilities):
     : $ apt-get -u install autoconf autogen libpcre3-dev bison yodl
     : $ git clone git@github.com:swig/swig.git
     : $ cd swig
     : $ autoconf
     : $ ./autogen.sh
     : $ ./configure && make && make install

** Licensing

   All ezpwd-reed-solomon code is available under both GPLv3 and Commercial
   licenses.  Phil's original Reed-Solomon code is LGPL, so my Reed-Solomon
   implementation in ezpwd-reed-solomon/c++/ezpwd/rs (which uses Phil's, with
   some improvements and conversion to C++) is available under the terms of the
   LGPL.

*** GPLv3 Licensing

    If your application complies with the terms of the GPLv3, then you can use
    EZPWD Reed-Solomon based APIs without cost.  All users of your software
    (eg. an installed application) or "software as a service" (eg. a website)
    must have access to all of the software source code so they can freely
    modify, rebuild and run the software.  Any modifications to underlying GPLv3
    software (ie. EZPWD) must also be made available.

*** Commercial Licensing and Pricing

    If you use any of the EZPWD Reed-Solomon based APIs in your product but you
    don't wish to make your product's or website's source code available, then a
    Commercial license from [[http://hardconsulting.com/products/13-reed-solomon][Hard Consulting Corporation (hardconsulting.com)]] is
    available.  The pricing breakdown is as follows (in USD$):

    |------------+-------+---------+---------------------------------|
    | Users avg. | Price | Support | Included application assistance |
    | (monthly)  |  USD$ | USD$/yr |                                 |
    |------------+-------+---------+---------------------------------|
    | <1K        |     0 |      25 | Interesting project? ask... :)  |
    | 1K-10K     |   100 |      25 | 1 hour                          |
    | 10K-1M     |  1000 |     250 | 4 hours                         |
    | >1M        | 10000 |    2500 | 16 hours                        |
    |------------+-------+---------+---------------------------------|

    Use of the EZCOD robust geolocation encoding module of EZPWD Reed-Solomon is
    free, forever, for any application.  It is available under both GPLv3 and
    free Commercial licenses, and may even be re-implemented freely in any
    language, so long as it remains compatible (includes the Reed-Solomon error
    correction, and equivalent encoding and decoding of Latitude and Longitude
    coordinates).

    Call us at +1-780-970-8148 or email us at info@hardconsulting.com to discuss
    your application.

** Enhancements

   Several enhancements have been made to Phil's implementation.

*** Rejects impossible error position

    Phil's version allows the R-S decode to compute and return error positions
    with the unused portion of the Reed-Solomon codeword.  We reject these
    solutions, as they provide indication of a failure.

    The supplied data and parity may not employ the full potential codeword size
    for a given Reed-Solomon codec.  For example, and RS(31,29) codec is able to
    decode a codeword of 5-bit symbols containing up to 31 data and parity
    symbols; in this case, 2 parity symbols (31-29 == 2).

    If we supply (say) 9 data symbols and 2 parity symbols, the remaining 20
    symbols of unused capacity are effectively filled with zeros for the
    Reed-Solomon encode and decode operations.

    If we decode such a codeword, and the R-S Galois field solution indicates an
    error positioned in the first 20 symbols of the codeword (an impossible
    situation), we reject the codeword and return an error.

*** Shared data tables w/ optional locking

    Instead of re-computing all of the required data tables used by the
    Reed-Solomon computations, every instance of RS<CAPACITY,*> with compatible
    Galois polynomial parameters shares a common set of tables.  Furthermore,
    every instance of RS<CAPACITY,PAYLOAD> w/ compatible Galias polynomial
    parameters shares the tables specific to the computed number of parity
    symbols.

    The initialization of these tables is protected by a Mutex primitive and
    Guard object.  These default to 'int' (NO-OP), but if a threading mutex and
    guard are provided, the shared initialization is thread-safe.

** ezpwd::RS<...>: C++ Reed-Solomon API

   C++ implementation of Reed-Solomon codec.  Fully implemented as inline code,
   in C++ header files.  Highly performant, in both C++ and Javascript.

   #+BEGIN_SRC C++
   #include <ezpwd/rs>

   // Reed Solomon codec w/ 255 symbols, up to 251 data, 4 parity symbols
   ezpwd::RS<255,251> rs;

   std::vector<uint8_t> data;

   // ... fill data with up to 251 bytes ...

   rs.encode( data ); // Add 4 Reed-Solomon parity symbols (255-251 == 4)

   // ... later, after data is possibly corrupted ...

   int fixed = rs.decode( data ); // Correct errors, discard 4 R-S parity symbols
   #+END_SRC

* RSKEY: Data Key API

  Asking a user to reliably enter even a few bytes of data (eg. a product key
  or a redemption code) is, well, basically impossible.  It is not reasonable
  to expect that someone will be able to perfectly read and enter a blob of
  random letters and numbers with 100% reliability.

  Import =js/ezpwd/rskey.js= to use RSKEY error-corrected binary data input
  tokens in your application.  Raw binary data (in Javascript string or
  ArrayBuffer) can be encoded into an RSKEY for later entry by a user.  Using
  built-in parity (extra validation) symbols, any errors or missing symbols can
  be detected and possibly recovered.  An RSKEY that validates as correct can be
  trusted with a high degree of certainty, proportional to the number of excess
  parity symbols remaining (beyond those consumed by error detection and
  correction).

** Javascript Library: js/ezpwd/rskey.js

   : rskey_<PARITY>_encode( <bytes>, data, [ sep ] ) -- encode data to RSKEY
   : rskey_<PARITY>_decode( <bytes>, key )           -- decode RSKEY 

   PARITY of 2-5 is supported, with a maximum capacity of 31-PARITY bytes of
   base-32 encoded data (raw data expands by the factor ( <bytes> * 8 + 4 ) / 5
   when base-32 encoded).  With PARITY 2, the maximum capacity is 18 bytes; with
   PARITY 5, 16 bytes.
   
   The =data= may be an ArrayBuffer of byte-length <= =<bytes>=.  If a string is
   supplied, it may be a hex string beginning with '0x...' (all subsequent pairs
   of hex digits are used; any data beyond that is ignored).  Otherwise, the
   string is decoded as utf-8 (of course, this means that you can't supply a
   utf-8 string that starts with '0x'...).

   The optional =sep= parameter (default 5) is the cluster size to separate the
   RSKEY into; 0 specifies no separators.

   Load the rskey.js Javascript into your project:
   #+BEGIN_SRC HTML
   <script
     src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.4.0/js/ezpwd/rskey.js">
   </script>
   #+END_SRC

   Use rskey.js's API to encode your data into an easily human readable key.
   Call the =rskey_<PARITY>_encode= API (with PARITY 2-5), specify the number of
   bytes of data to encode in the RSKEY's payload, and provide some data to
   encode (as a hex string "0x3344...", or as a utf-8 string):
  
   #+BEGIN_SRC Javascript
   > rskey_5_encode( 12, "Mag.1ckπ" );
   "9MGNE-BHHCD-MVY00-00000-MVRFN"
   #+END_SRC
  
   Later, you can decode it -- even if the user adds an error or two (the 'X',
   below), or skips a few symbols (if some were unreadable, as indicated by an
   '\_', or the last few are simply not yet entered).  Each error consumes 2
   parity symbols, each erasure or missing symbol uses 1, therefore 1 error + 2
   erasures results in 20% of parity remaining for validation:
  
   #+BEGIN_SRC Javascript
   > rskey_5_decode( 12, "9MGNE-BHHCD-MVY00-00000-MVRFN" )
   {confidence: 100, data: ArrayBuffer, utf8: "Mag.1ckπ", hex: "0x4D61672E31636BCF80000000"}
   > rskey_5_decode( 12, "9MGNE-BHHCD-MVY00-00X00-MVR" ) // 1 error, 2 not yet entered
   {confidence: 20, data: ArrayBuffer, utf8: "Mag.1ckπ", hex: "0x4D61672E31636BCF80000000"}
   > rskey_5_decode( 12, "9_GNE-BHH_D-MVY00-00X00-MVRFN" ) // 1 error, 2 unreadable w/ '_'
   {confidence: 20, data: ArrayBuffer, utf8: "Mag.1ckπ", hex: "0x4D61672E31636BCF80000000"}
   #+END_SRC
  
   If you have raw numeric data (eg. record IDs, data HMACs, etc), use the
   ArrayBuffer interface.  You can supply any type of raw data, up to the
   capacity of the RSKEY (12 bytes, in this case).  Then, even if errors are
   introduced on entry, they will be recovered if the parity is sufficient, and
   the returned Object's .data property will be an ArrayBuffer containing the
   original binary data, which you can used a TypedArray to access:
  
   #+BEGIN_SRC Javascript
   > ia = new Int32Array([0x31323334, 0x41424344, 0x51525354])
   [825373492, 1094861636, 1364349780]
   > rskey_5_encode( 12, ia.buffer ) // raw capacity is 12 bytes, w/ 5 parity
   "6GRK4-CA48D-142M2-KA98G-V2MYP"
   > dec=rskey_5_decode( 12, "6GRK4-CA48D-142M2-KA98G-V2XXP" ) // XX are errors
   {confidence: 20, data: ArrayBuffer, utf8: "4321DCBATSRQ", hex: "0x343332314443424154535251"}
   > new Int32Array( dec.data ) // recover original data
   [825373492, 1094861636, 1364349780]
   #+END_SRC

** RSKEY Demo: http://rskey.hardconsulting.com

   Try changing the Parity, Data Size and Data.  Try changing the Key by
   entering some _ (indicating a missing/invalid symbol).  These are called
   Erasures in Reed-Solomon terms, and we can recover one Erasure with each
   Parity symbol.  Try changing some Key values to incorrect values.  These
   Reed-Solomon Errors each require 2 Parity symbols to detect and correct.

   You can also access the Console (right click, select Inspect Element, click
   on "Console"), and enter the above =rskey_=... API example code.

** Example Node.JS: Encrypted Gift Card Codes

   Lets say you have an online Widget business, and generate gift cards.  You
   average about 5000 unique visitors/month over the year, with a peak of 25000
   around Christmas.  You want to make your gift card redemption more reliable
   and secure, and less painful for your clients.

   Your RSKEY license cost would be $100, plus a $25/yr support subscription,
   and you would have access to an hour of time with a support developer to help
   you apply the js/ezpwd/rskey.js API to your website's gift card generation
   and redemption pages.

   You decide to associate each gift card with the buyer's account (so you and
   the gift-card giver can know when the card is redeemed).  So, each gift
   card RSKEY needs to contain:
   - a 32-bit customer ID
   - a 32-bit gift card ID

   Using an RSKEY encoding 8 bytes of data, with 3 parity symbols, we get
   protection against 1 error or 2 erased symbols, with 1 parity symbol left
   over for validation.

   See =rskey_node.js= for sample code (the communication of the JSON request
   and reply between the client Website and the Node.JS server is left as an
   excercise to the reader.)

*** Client Website RSKEY Implementation

    On the client website, you would use something like:

#+BEGIN_SRC Javascript
<script
  src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.4.0/js/ezpwd/rskey.js">
</script>
<script>
var client = {
    // 
    // card_key_encode( card ) -- encrypt card's IDs on the server, return RSKEY
    // card_key_decode( key )  -- recover RSKEY, decrypt IDs on server, return card
    // 
    //     These are run in the browser, and expect to call server methods that
    // run under Node.js back on the server.  For this demo, we'll all just run
    // here in Node.js...
    // 
    card_key_encode: function( card ) {
        // Get the server to encrypt the card IDs
        server.card_keydata_encode( card );
        // Produce the RSKEY from the card's keydata w/ Uint8Array's ArrayBuffer
        card.key = rskey_3_encode( 8, new Uint8Array( card.keydata ).buffer, 4 );
        return card.key;
    },

    card_key_decode: function( key ) {
        // Decode the ASCII key; will raise an Exception if decode fails
        var keyinfo = rskey_3_decode( 8, key );

        // Convert ArrayBuffer (as Uint8Array) to plain javascript Array
        var keyuint8 = new Uint8Array( keyinfo.data );
        var keydata = Array( 8 );
        for ( var i = 0; i < 8; ++i )
            keydata[i]	= keyuint8[i];

        // Get the server to decrypt the card.keydata, return the card IDs
        return server.card_keydata_decode({ keydata: keydata });
    }
}

// Your first customer ever, buys his first gift card!
card = {
    id: 0,
    customer: { id: 0 },
}

// Encode the card IDs to RSKEY
card_key = client.card_key_encode( card );
// ==> {
//   customer: { id: 0 },
//   id: 0,
//   keydata: [ 185, 124, 29, 95, 168, 45, 159, 113 ],
//   key: 'P5X1-TPW8-5NFP-2M7G'
// }
//
// "P5X1-TPW8-5NFP-2M7G" is printed/emailed on gift card
// 
#+END_SRC

    Later on, the gift card recipient comes back to the website and enters the
    gift-card key during checkout, mistyping some symbols, and using lower-case
    and alternative whitespace (the base-32 encoding handles the Z/z/2, S/s/5,
    I/i/1 and O/o/0 substitutions (these symbols are equivalent in EZPWD
    base-32); the W/v substitution is an error):

#+BEGIN_SRC Javascript
// Decode the customer-entered data using the same RSKEY parameters:
//                          error:         v
//                    equivalents:   v v      v    v
//                       original: "P5X1-TPW8-5NFP-2M7G"
card_dec = client.card_key_decode( "psxi tpv8 snfp zm7g" );
// ==> {
//   keydata: [ 185, 124, 29, 95, 168, 45, 159, 113 ],
//   customer: { id: 0 },
//   id: 0
// }
// 
// This is gift card ID 0, purchased by our very first customer ID 0! Find out
// what that gift card is still worth, and apply it to the order...
// 
#+END_SRC

*** Server Node.js Encryption Implementation

    All encryption should take place on the server, with a secret symmetric
    encryption key (which should not be stored in the repo!  Use other secure
    key storage, or existing key material already on the server).  Encrypt on
    the server using an appropriate cipher that either encrypts all 64 bits as
    a block (such as =blowfish=).

#+BEGIN_SRC Javascript

/*
 * rskey_node.js -- Demonstrate use of rskey in Node.js application
 * 
 *     Node.js "crypto" uses the Buffer type to manipulate binary data.  The
 * rskey library uses ArrayBuffer, because it is intended to be used in both
 * Node.js and Browser Javascript applications.
 * 
 *    The server will expect an Object containing (at least) card.id and
 * card.customer.id, and produce/consume card.keydata.
 * 
 */
var crypto		= require( "crypto" );
var crypto_algo		= 'blowfish'; // 64-bit block cipher
var crypto_secret	= 'not.here'; // Super secret master key; don't keep in Git...

var server = {
    //
    // card_keydata_encode -- Encipher card IDs into card.keydata Array
    // card_keydata_decode -- Decipher card IDs from card.keydata Array
    // 
    //     Run these on your server (of course, keeping crypto_secret... secret.)
    // 
    card_keydata_encode: function( card ) {
        // Create Buffer containing raw card ID data
        var buf		= new Buffer( 8 );
        buf.writeUInt32LE( card.customer.id,	0 );
        buf.writeUInt32LE( card.id,		4 );

        // Encrypt the Buffer of keydata
        var encipher	= crypto.createCipher( crypto_algo, crypto_secret );
        encipher.setAutoPadding( false ); // must use exact 64-bit blocks
        var enc		= Buffer.concat([ 
            encipher.update( buf ),
            encipher.final()
        ]);

        // Return card w/ encrypted IDs as plain Javascript Array in .keydata
        card.keydata	= enc.toJSON().data; // {type: 'Buffer', data: [1,2,...]}
        return card;
    },

    card_keydata_decode: function( card ) {
        if ( card.keydata.length != 8 )
            throw "Expected 8 bytes of card.keydata, got: " + card.keydata.length;

        // Decrypt the Buffer of keydata
        var decipher	= crypto.createDecipher( crypto_algo, crypto_secret );
        decipher.setAutoPadding( false ); // must use exact 64-bit blocks
        var dec		= Buffer.concat([
            decipher.update( new Buffer( card.keydata )),
            decipher.final()
        ]);

        // Recover raw card IDs from Buffer
        if ( card.customer == undefined )
            card.customer = {};
        card.customer.id= dec.readUInt32LE( 0 );
        card.id		= dec.readUInt32LE( 4 );
        return card;
    }
};
#+END_SRC    

    Assuming that an attacker does not have access to the encryption key used
    by the server to encrypt the customer and card IDs in a single 64-bit
    block, then the probability of a fake key being produced and accepted is
    vanishingly small.

    Lets assume that they *do* know that you are using EZPWD Reed-Solomon, and
    therefore always present RSKEYs that are valid R-S codewords.  Furthermore,
    lets assume that you have alot of customers (> 2 billion), so your 32-bit
    customer ID is likely to accidentally match a valid customer with a
    probability >50%.

    The decrypted customer and card IDs must be correct -- match a valid
    customer and card ID.  Since it is unlikely for each customer to generate
    more than a handful of gift cards, the probability that the 32-bit card ID
    will accidentally decrypt to any given value is 1/2^32 (1 in ~4
    billion). The combined 64-bit RSKEY (remember: all data must be encrypted
    with a block cipher)indexes a sparsely populated array of
    valid values; given a number in the range (0,2^64], only every 4-billionth
    value will turn out to be valid (much less than that, in realistic
    scenarios).

    Therefore, an attacker must generate and try more than 2 billion valid
    RSKEYs before they have a 50% chance of stumbling upon one that matches a
    valid gift card, given the above (generous) assumptions.  Even if you don't
    rate-limit your card redemption API, you might notice that your server is
    saturated with gift-card redemption requests.  Assuming that your server
    can process 1000 redemptions per second, it would take the attacker 23 days
    (2,000,000 seconds) to have a 50% chance of finding his first valid fake
    key.  So, I recommend rate-limiting your gift-card redemption API to 10
    request per second, increasing the time to 6 years.

    Therefore, using RSKEY and a simple encoding scheme presents an effective,
    robust and secure means of generating and redeeming gift-card codes.

    Customer aggravation due to mis-typed codes is reduced, increasing the
    likelihood of return visits and positive reviews.

* EZCOD: Location Code API

  To specify the location of something on the surface of the earth, a Latitude,
  Longitude pair is typically used.   To get within +/-3m, a Latitude, Longitude
  pair with at least 5 digits of precision after the decimal point is required.

  So, to specify where my daughter Amarissa was born, I can write down the
  coordinate:
  : 53.655832,-113.625433

  This is both longer and more error prone than writing the equivalent EZCOD:
  : R3U 1JU QUY.0

  If a digit is wrong in the Latitude or Longitude coordinate, the amount of error
  introduced is anywhere from a few centimeters to many kilometers:
  : 53.655832,-113.62543X == centimeters error
  : 53.655832,-1X3.625433 == many kilometers error

  EZCOD uses error/erasure correction to correct for up to 1 known missing
  (erased) symbol by default, with greater erasure/error detection and
  correction optionally available.

** Javascript Library: js/ezpwd/ezcod.js:

   : ezcod_3_10_encode( lat, lon, [ symbols ] ) -- encode location to EZCOD
   : ezcod_3_10_decode( ezcod )                 -- decode EZCOD to position

   There are three variants provided:
   - =ezcod_3_10_...= -- 1 parity symbol
   - =ezcod_3_11_...= -- 2 parity symbols
   - =ezcod_3_12_...= -- 3 parity symbols

   Load the ezcod.js Javascript into your project:
   #+BEGIN_SRC HTML
   <script
    src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.4.0/js/ezpwd/ezcod.js">
   </script>
   #+END_SRC

   To encode a position of center of the Taj Mahal dome to 3m accuracy (9
   position symbols, the default) and 20mm accuracy (12 symbols), and with 3
   parity symbols (5-nines confidence):
   #+BEGIN_SRC Javascript
   > ezcod_3_12_encode( 27.175036985,  78.042124565 ) // default: 3m (9 symbols)
   "MMF BBF GC1.2U2"
   > ezcod_3_12_encode( 27.175036985,  78.042124565, 12 ) // 20mm (12 symbols)
   "MMF BBF GC1 A16.1VD"
   #+END_SRC
  
   Later, if the EZCOD is entered, errors and erasures are transparently
   corrected, up to the capacity of the Reed-Solomon encoded parity:
   #+BEGIN_SRC Javascript
   > ezcod_3_12_decode( "MMF BBF GC1 A16.1VD" )
   Object {confidence: 100, latitude: 27.17503683641553, longitude: 78.04212455637753,
       accuracy: 0.020401379521588606}
   > ezcod_3_12_decode( "MMF BBF GC1 A16.1" ) // missing some parity
   Object {confidence: 34, latitude: 27.17503683641553, longitude: 78.04212455637753,
       accuracy: 0.020401379521588606}
   > ezcod_3_12_decode( "mmf-bbf-Xc1-a16.1vd" ) // An error
   Object {confidence: 34, latitude: 27.17503683641553, longitude: 78.04212455637753,
       accuracy: 0.020401379521588606}
   #+END_SRC
  
   Try it at [[http://ezcod.com][ezcod.com]].  Switch to "EZCOD 3:12", and enter "mmf-bbf-Xc1-a16.1vd"
   as the EZCOD.  You will see a computed accuracy of 20.4mm, and observe that
   the 'X' (error) is corrected to "G".  (The website defaults to 9 digits of
   precision, so it will re-encode the position, discarding the extra
   precision.)

** Python Library: ezpwd\_reed\_solomon

   The Python =ezpwd_reed_solomon= package contains an =ezcod= sub-module.
   While fully functional, it is designed to be simple to augment, should your
   geolocation encoding needs be unique.

   It is extremely simple to add new EZCOD APIs to the Python binding.  Simply
   edit the =swig/python/ezcod/ezcod.i= file, and re-install the Python binding.
   For example, to add a new binding class called =ezcod.ezcod_20mm_15= (with
   20mm accuracy in 12 location encoding symbols + .99997 certainty in 3 parity
   symbols), add the following to the bottom of =ezcod.i=:
   #+BEGIN_EXAMPLE
   %template(ezcod_20mm_15)	ezpwd::ezcod<3,12>;
   #+END_EXAMPLE

*** =ezpwd_reed_solomon.ezcod=

    Classes are provided to produce three variants of EZCOD by default: 3m (9
    symbols) of location accuracy, plus 1, 2 or 3 Reed-Solomon parity symbols.
    They are named =ezcod_3_10=, =ezcod_3_11= and =ezcod_3_12=, respectively,
    indicating the default 3m accuracy, and the total number of symbols.
    #+BEGIN_EXAMPLE
    $ python
    >>> from ezpwd_reed_solomon import ezcod
    #+END_EXAMPLE

    The API supports the following methods and attributes:

**** =ezcod_3_{10,11,12}( "<EZCOD>"|[lat,[lon,[seper,[chunk]]]] )=

     Creates an <ezcod> instance containing the specified geolocation (defaults
     to latitude 0.0, longitude 0.0, '.' separator and chunk 3).  If a string is
     supplied, it is decoded (if possible; an Exception is raised if the
     provided EZCOD is invalid).
     #+BEGIN_EXAMPLE
     >>> EZCOD = ezcod.ezcod_3_12( 53.5, -113.8 )
     >>> print repr( EZCOD )
     <R3U 06B MJ3.JXR (100%)  ==  +53.5000000000, -113.8000000000 +/-   0.00mm>
     #+END_EXAMPLE

**** =ezcod_3_{10,11,12}.encode( [precision] )=

     Encodes the current ezcod_3_{10,11,12}'s =.latitude= and =.longitude= to
     the given number of symbols of precision (default: 9, or 3m).  The accuracy
     may be anywhere from 1 to 12 (20mm accuracy) symbols.
     #+BEGIN_EXAMPLE
     >>> print EZCOD.encode( 12 )
     R3U 06B MJ3 EDD.K56
     #+END_EXAMPLE

**** =ezcod_3_{10,11,12}.decode( "<EZCOD>" )=

     Any variant of ezcod_3_{10,11,12} can decode a valid EZCOD, so long as it
     contains a '.' or '!' to separate the position and R-S parity symbols.  The
     percentage certainty is returned -- the proportion of R-S parity symbols
     that remain unused after error detection and correction.  A value of 0
     indicates that the EZCOD's R-S decoding did not fail, but no parity symbols
     remain in excess to verify its validity.
     #+BEGIN_EXAMPLE
     >>> print EZCOD.decode( "r3u 06b mj3 edd.k56" )
     100
     >>> EZCOD.latitude
     53.49999999627471
     >>> print EZCOD.decode( "r3u O6b m_3 edd.k56" )
     67
     >>> print EZCOD.decode( "r3u O6b mX3 edd.k56" )
     34
     >>> print repr( EZCOD )
     <R3U 06B MJ3.JXR ( 34%)  ==  +53.4999999963, -113.8000000734 +/-   19.4mm>
     >>>
     #+END_EXAMPLE

     If any symbols are unknown, replace them with either =_= or =?= to
     indicate that they are erasures (and consume only a single symbol of R-S
     parity to correct).  Any undetected erroneous symbol corrected by the R-S
     codec consumes 2 parity symbols.  A failure to decode (too many errors or
     erasures) will raise a =RuntimeError= exception:
     #+BEGIN_EXAMPLE
     >>> EZCOD.decode( "r3u 06b mj3 __d.__6" )
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
         ...
     RuntimeError: ezpwd::ezcod::decode: Error correction failed; too many erasures
     >>> EZCOD.decode( "r3u 06b mj3 eXd.__6" )
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
         ...
     RuntimeError: ezpwd::ezcod::decode: Error correction failed; R-S decode failed
     #+END_EXAMPLE

**** =ezcod_3_{10,11,12}= Instance Attributes

     The following attributes are available in each =ezcod_3_{10,11,12}=
     instance:

     | Attribute        | Type  | Range         | Description                             |
     |------------------+-------+---------------+-----------------------------------------|
     | latitude         | float | [-90,90]      | Geographical position in degrees        |
     | longitude        | float | [-180,180]    | ''                                      |
     | latitude\_error  | float | [0,inf]       | Axis error in meters                    |
     | longitude\_error | float | [0,inf]       | ''                                      |
     | accuracy         | float | [0,inf]       | Average of error ellipse axes in meters |
     | precision        | int   | [1,12]        | Desired number of location symbols      |
     | confidence       | int   | [0,100]       | Percentage of parity symbols remaining  |
     | chunk            | int   | [0,6]         | Spaces every 'chunk' position symbols   |
     | seperator        | char  | '.', '!', ' ' | SEP\_NONE/DEFAULT/DOT/BANG/SPACE        |
     | space            | char  | ' ', '-'      | CHK\_NONE/DEFAULT/SPACE/DASH            |
     | SEP\_NONE        | char  | '\xff'        | Output no position/parity separator     |
     | SEP\_DEFAULT     | char  | '\x00'        | Output no position/parity separator     |
     | SEP\_DOT         | char  | '.' (default) | Output a '.' position/parity separator  |
     | SEP\_BANG        | char  | '!'           | Output a '!' position/parity separator  |
     | SEP\_SPACE       | char  | ' '           | Output a ' ' position/parity separator  |
     | CHK\_NONE        | char  | '\xff'        | Output no space between chunks          |
     | CHK\_DEFAULT     | char  | '\x00'        | Output the default between chunks       |
     | CHK\_SPACE       | char  | ' ' (default) | Output a ' ' space between chunks       |
     | CHK\_DASH        | char  | '-'           | Output a '-' space between chunks       |


     It is recommended to use either =SEP_DOT= (default) or =SEP_BANG=, so that
     the EZCOD parser can unambiguously determine the total EZCOD size, and the
     number of parity symbols to expect.

*** Asynchronous Loading

    Emscripten-generated code must have its run-time initialized before it can
    be called.  If you get Javascript resources normally, they will load
    asynchronously, but be run in the order you load them so the Emscripten
    run-time will be safely initialized before your applivation's Javascript
    runs.
 
    If you load other Javascript libraries like jQuery and your application.js,
    and you load ezcod.js asynchronously, you must ensure that they do not use
    any Emscripten libraries (such as ezcod.js) until their run-time
    initialization is complete.  Our Emscripten-based libraries are completely
    self-contained, so you can use the =<script onload...>= to signal jQuery to
    trigger its =on( 'ready', ... )= event.  Regardless of whether
    =jquery.min.js= or =ezcod.js= loads first, this code will ensure that your
    =app.js= =on( 'ready', ... )= event will not fire until =ezcod.js= has its
    Emscripten run-time initialized:
 
    #+BEGIN_SRC HTML
    <script type="text/javascript">
       // Bindings for Emscripten initialization detection.
       var jquery_release = function() {
           console.log( "Emscripten run-time initialized before jQuery loaded" );
           jquery_loaded = function() {}; // nothing left to do after jquery loads
       };
       var jquery_loaded = function() {
           console.log( "Emscripten run-time initialize blocking jQuery..." );
           $.holdReady(true);		// force delay of jQuery.on( 'ready', ...
           jquery_release = function() {
               console.log( "Emscripten run-time initialized; jQuery released" );
               $.holdReady(false);	// ... 'til Emscripten runtime initialized
           };
       };
    </script>
    <script async onload="jquery_release()"
        src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.4.0/js/ezpwd/ezcod.js">
    </script>
    <script defer onload="jquery_loaded()"
        src="//ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js">
    </script>
    <script defer
        src="js/app.js">
    </script>
    #+END_SRC

** Robustness

   All symbols after the initial 9 are Reed-Solomon code symbols.  Each R-S
   symbol can recover one known erasure; every two R-S symbols can detect and
   correct one other erroneous symbol.  If any R-S symbols remains unused in
   excess of all erasures and errors, then the entire sequence can be confirmed
   as an R-S "codeword", and its validity is assured, to a probability of:
   : P(1-1/2^(5*excess))

   For example, with one R-S symbol remaining, the probability that the EZCOD
   is correct is:
   : P(1-1/2^5) == .969
   If two excess R-S symbols exist, then the
   probability rises to:
   : P(1-1/2^10) == P(1-1/1024) == 0.999
   With 3, it's:
   : P(1-1/2^15) == P(1-1/32768) == 0.99997

   Therefore, if extremely robust positions are required, select an EZCOD with
   3 parity symbols, yielding almost 5-nines reliability in transmitting
   accurate position information -- even if it must be written down, recited or
   entered by a human.

** Precision

   To identify the location of something within +/- 10 feet (3m) is simple: you
   must specify the Latitude (-90,90) to within 1 part in 4,194,304 (2^22) and
   Longitude (-180,180) to within 1 part in 8,388,608 (2^23).

   The default 10-symbol EZCOD transmits 22 bits of Latitude and 23 bits of
   Longitude in 9 symbols of position data (the 10th is a parity symbol).  The
   EZCOD API can encode up to 12 symbols of position data (29 bits of Latitude,
   and 31 bits of Longitude), yielding a maximum precision capability of +/- 20
   millimeters.

   Since the earth's circumference at the equator is ~40,075,000m, each part in
   both vertical and horizontal directions is 40,075,000 / 8,388,608 == 4.777m.  If
   you can specify a rectangle having sides of length equal to one part in the
   vertical and horizontal direction, then at the equator, you have a square that
   is 4.777m on a side.  So, if we know which square some geographical coordinate
   lies within, it is at most sqrt( 2 * (4.777/2)^2 ) == 3.378m distant from the
   center of the square.

   As you travel north or south, the circumference of the Longitude lines
   decreases, as absolute Latitude increases.  The average radius of the earth is
   ~6,371,000m.  At 53 degrees North, the circumference of the earth along a line
   of fixed Latitude is:
   : 2 * pi * radius * cos( Latitude )
   : 2 * 3.1415926534 * 6,371,000m * 0.60181502315
   : 24,090,760m

   Thus, each part along the vertical axis is still 4.777m, but each horizontal
   part is:
   : 24,090,760 / 8,388,608 == 2.872m.

   Now the point within each rectangle is at most:
   : sqrt( (4.777/2)^2 + (2.872/2)^2 ) == 2.787m
   distant from the center of the rectangle.

   Thus, with 9 symbols of position data, the precision of such a
   Latitude/Longitude encoding is at worst +/- 3.378m at the equator, at best
   +/-2.389m at the poles, and has an average error of less than +/-3m.

** EZCOD Demo: http://ezcod.com

   To see EZCOD in action, visit [[http://ezcod.com][ezcod.com]].  Try entering:
   : R3U 1JU QUY.0
   to see where my daughter Amarissa was born.

   You can also access the Console (right click, select Inspect Element, click
   on "Console"), and enter the above =rskey_=... API example code.

* RSPWD: Password Correction API

  Javascript implementation of Reed-Solomon codec based password error
  detection and correction.

** Javascript Library: js/ezpwd/rspwd.js
