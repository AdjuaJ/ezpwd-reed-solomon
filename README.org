# -*- coding: utf-8 -*-
#+TITLE: EZPWD Reed-Solomon Version 1.1.1

* Reed-Solomon Loss/Error Correction Coding

  Error and erasure detection and correction for C++ and Javascript programs.
  Based on Phil Karn's excellent implementation (as used by the Linux kernel),
  converted to C++.

  Several C++ and Javascript utilities implemented using Reed-Solomon are
  provided.

  The Javascript APIs are produced from the C++ implementation using
  =emscripten=, and are very performant.  All Javascript is available for
  inclusion in websites via MaxCDN.

** Performance: 25-75% Faster Than Competing Codecs

   The Reed-Solomon codec's performance is often a critical determinant in
   product performance, and often influences expensive decisions such as CPU
   selection for embedded applications.

   EZPWD Reed Solomon performs R-S correction operations (using g++ on an Intel
   i7) about 75% faster faster than Phil Karn's general case code, and about 25%
   faster than Phil's optimized code for 8-bit/CCSDS symbols.  It also tests at
   about 25% faster than the Shifra C++ Reed-Solomon library.  It appears that,
   for certain applications at least, EZPWD Reed-Solomon may be the fastest
   generally available C++ Reed-Solomon library available.

** Availability

   Source code is hosted at [[https://github.com/pjkundert/ezpwd-reed-solomon]].  It
   is heavily tested under both g++ and clang++, with full optimization enabled.

*** Javascript Hosted by MaxCDN

    Production minified Javascript is served by MaxCDN, using a URL like:
   [[ https://cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.1.1/js/ezpwd/ezcod.js]].

    For example, to use the EZCOD position encoding API in your website, add
    this at the end of your website template, before your application.js:
    #+BEGIN_SRC HTML
    <script
      src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.1.1/js/ezpwd/ezcod.js">
    </script>
    #+END_SRC

    Note the current <VERSION> number encoded in the URI as =.../v<VERSION>/...".

    Your application may permanently access any current or historical version of
    the EZPWD Reed-Solomon Javascript which has a Tag in the official Git repo,
    by encoding the <VERSION> number in the URL: 
    : //cdn.rawgit.com/.../v<VERSION>/...

** Licensing

   All ezpwd-reed-solomon code is available under both GPLv3 and Commercial
   licenses.  Phil's original Reed-Solomon code is LGPL, so my Reed-Solomon
   implementation in ezpwd-reed-solomon/c++/ezpwd/rs (which uses Phil's, with
   some improvements and conversion to C++) is available under the terms of the
   LGPL.

*** GPLv3 Licensing

    If your application complies with the terms of the GPLv3, then you can use
    EZPWD Reed-Solomon based APIs without cost.  All users of your software
    (eg. an installed application) or "software as a service" (eg. a website)
    must have access to all of the software source code so they can freely
    modify, rebuild and run the software.  Any modifications to underlying GPLv3
    software (ie. EZPWD) must also be made available.

*** Commercial Licensing and Pricing

    If you use any of the EZPWD Reed-Solomon based APIs in your product but you
    don't wish to make your product's or website's source code available, then a
    Commercial license is appropriate.  The pricing breakdown is as follows (in
    CAD$):

    |------------+-------+---------+---------------------------------|
    | Users avg. | Price | Support | Included application assistance |
    | (monthly)  |  CAD$ | CAD$/yr |                                 |
    |------------+-------+---------+---------------------------------|
    | <1K        |     0 |      25 | Interesting project? ask... :)  |
    | 1K-10K     |   100 |      25 | 1 hour                          |
    | 10K-1M     |  1000 |     250 | 4 hours                         |
    | >1M        | 10000 |    2500 | 16 hours                        |
    |------------+-------+---------+---------------------------------|

    Use of EZCOD is free, forever, for any application.  It is available under
    both GPLv3 and free Commercial licenses, and may even be reimplemented in
    any language, so long as it remains compatible (includes the Reed-Solomon
    error correction, and equivalent encoding and decoding of Latitude and
    Longitude coordinates).

    Call us at +1-780-970-8148 or email us at info@hardconsulting.com to discuss
    your application.

** Enhancements

   Several enhancements have been made to Phil's implementation.

*** Rejects impossible error position

    Phil's version allows the R-S decode to compute and return error positions
    with the unused portion of the Reed-Solomon codeword.  We reject these
    solutions, as they provide indication of a failure.

    The supplied data and parity may not employ the full potential codeword size
    for a given Reed-Solomon codec.  For example, and RS(31,29) codec is able to
    decode a codeword of 5-bit symbols containing up to 31 data and parity
    symbols; in this case, 2 parity symbols (31-29 == 2).

    If we supply (say) 9 data symbols and 2 parity symbols, the remaining 20
    symbols of unused capacity are effectively filled with zeros for the
    Reed-Solomon encode and decode operations.

    If we decode such a codeword, and the R-S Galois field solution indicates an
    error positioned in the first 20 symbols of the codeword (an impossible
    situation), we reject the codeword and return an error.

*** Shared data tables w/ optional locking

    Instead of re-computing all of the required data tables used by the
    Reed-Solomon computations, every instance of RS<CAPACITY,*> with compatible
    Galois polynomial parameters shares a common set of tables.  Furthermore,
    every instance of RS<CAPACITY,PAYLOAD> w/ compatible Galias polynomial
    parameters shares the tables specific to the computed number of parity
    symbols.

    The initialization of these tables is protected by a Mutex primitive and
    Guard object.  These default to 'int' (NO-OP), but if a threading mutex and
    guard are provided, the shared initialization is thread-safe.

** ezpwd::RS<...>: C++ Reed-Solomon API

   C++ implementation of Reed-Solomon codec.  Fully implemented as inline code,
   in C++ header files.  Highly performant, in both C++ and Javascript.

   #+BEGIN_SRC C++
   #include <ezpwd/rs>

   // Reed Solomon codec w/ 255 symbols, up to 251 data, 4 parity symbols
   ezpwd::RS<255,251> rs;

   std::vector<uint8_t> data;

   // ... fill data with up to 251 bytes ...

   rs.encode( data ); // Add 4 Reed-Solomon parity symbols (255-251 == 4)

   // ... later, after data is possibly corrupted ...

   int fixed = rs.decode( data ); // Correct errors, discard 4 R-S parity symbols
   #+END_SRC

* RSKEY: Javascript Data Key API

  Asking a user to reliably enter even a few bytes of data (eg. a product key
  or a redemption code) is, well, basically impossible.  It is not reasonable
  to expect that someone will be able to perfectly read and enter a blob of
  random letters and numbers with 100% reliability.

  Import =js/ezpwd/rskey.js= to use RSKEY error-corrected binary data input
  tokens in your application.  Raw binary data (in Javascript string or
  ArrayBuffer) can be encoded into an RSKEY for later entry by a user.  Using
  built-in parity (extra validation) symbols, any errors or missing symbols can
  be detected and possibly recovered.  An RSKEY that validates as correct can be
  trusted with a high degree of certainty, proportional to the number of excess
  parity symbols remaining (beyond those consumed by error detection and
  correction).

** Javascript Library: js/ezpwd/rskey.js

   : rskey_<PARITY>_encode( <bytes>, data, [ sep ] ) -- encode data to RSKEY
   : rskey_<PARITY>_decode( <bytes>, key )           -- decode RSKEY 

   PARITY of 2-5 is supported, with a maximum capacity of 31-PARITY bytes of
   base-32 encoded data (raw data expands by the factor ( <bytes> * 8 + 4 ) / 5
   when base-32 encoded).  With PARITY 2, the maximum capacity is 18 bytes; with
   PARITY 5, 16 bytes.
   
   The =data= may be an ArrayBuffer of byte-length <= =<bytes>=.  If a string is
   supplied, it may be a hex string beginning with '0x...' (all subsequent pairs
   of hex digits are used; any data beyond that is ignored).  Otherwise, the
   string is decoded as utf-8 (of course, this means that you can't supply a
   utf-8 string that starts with '0x'...).

   The optional =sep= parameter (default 5) is the cluster size to separate the
   RSKEY into; 0 specifies no separators.

   Load the rskey.js Javascript into your project:
   #+BEGIN_SRC HTML
   <script
     src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.1.1/js/ezpwd/rskey.js">
   </script>
   #+END_SRC

   Use rskey.js's API to encode your data into an easily human readable key.
   Call the =rskey_<PARITY>_encode= API (with PARITY 2-5), specify the number of
   bytes of data to encode in the RSKEY's payload, and provide some data to
   encode (as a hex string "0x3344...", or as a utf-8 string):
  
   #+BEGIN_SRC Javascript
   > rskey_5_encode( 12, "Mag.1ckπ" );
   "9MGNE-BHHCD-MVY00-00000-MVRFN"
   #+END_SRC
  
   Later, you can decode it -- even if the user adds an error or two (the 'X',
   below), or skips a few symbols (if some were unreadable, as indicated by an
   ='_'=, or the last few are simply not yet entered):
  
   #+BEGIN_SRC Javascript
   > rskey_5_decode( 12, "9MGNE-BHHCD-MVY00-00000-MVRFN" )
   {confidence: 100, data: ArrayBuffer, utf8: "Mag.1ckπ", hex: "0x4D61672E31636BCF80000000"}
   > rskey_5_decode( 12, "9MGNE-BHHCD-MVY00-00X00-MVR" ) // not yet entered
   {confidence: 20, data: ArrayBuffer, utf8: "Mag.1ckπ", hex: "0x4D61672E31636BCF80000000"}
   > rskey_5_decode( 12, "9_GNE-BHH_D-MVY00-00X00-MVRFN" ) // or unreable w/ _
   {confidence: 20, data: ArrayBuffer, utf8: "Mag.1ckπ", hex: "0x4D61672E31636BCF80000000"}
   #+END_SRC
  
   If you have raw numeric data (eg. record IDs, data HMACs, etc), use the
   ArrayBuffer interface.  You can supply any type of raw data, up to the
   capacity of the RSKEY (12 bytes, in this case).  Then, even if errors are
   introduced on entry, they will be recovered if the parity is sufficient, and
   the returned Object's .data property will be an ArrayBuffer containing the
   original binary data, which you can used a TypedArray to access:
  
   #+BEGIN_SRC Javascript
   > ia = new Int32Array([0x31323334, 0x41424344, 0x51525354])
   [825373492, 1094861636, 1364349780]
   > rskey_5_encode( 12, ia.buffer ) // raw capacity is 12 bytes, w/ 5 parity
   "6GRK4-CA48D-142M2-KA98G-V2MYP"
   > dec=rskey_5_decode( 12, "6GRK4-CA48D-142M2-KA98G-V2XXP" ) // XX are errors
   {confidence: 20, data: ArrayBuffer, utf8: "4321DCBATSRQ", hex: "0x343332314443424154535251"}
   > new Int32Array( dec.data ) // recover original data
   [825373492, 1094861636, 1364349780]
   #+END_SRC

** RSKEY Demo: http://rskey.hardconsulting.com

   Try changing the Parity, Data Size and Data.  Try changing the Key by
   entering some _ (indicating a missing/invalid symbol).  These are called
   Erasures in Reed-Solomon terms, and we can recover one Erasure with each
   Parity symbol.  Try changing some Key values to incorrect values.  These
   Reed-Solomon Errors each require 2 Parity symbols to detect and correct.

   You can also access the Console (right click, select Inspect Element, click
   on "Console"), and enter the above =rskey_=... API example code.

** Example Node.JS: Encrypted Gift Card Codes

   Lets say you have an online Widget business, and generate gift cards.  You
   average about 5000 unique visitors/month over the year, with a peak of 25000
   around Christmas.  You want to make your gift card redemption more reliable
   and secure, and less painful for your clients.

   Your RSKEY license cost would be $100, plus a $25/yr support subscription,
   and you would have access to an hour of time with a support developer to help
   you apply the js/ezpwd/rskey.js API to your website's gift card generation
   and redemption pages.

   You decide to associate each gift card with the buyer's account (so you and
   the gift-card giver can know when the card is redeemed).  So, each gift
   card RSKEY needs to contain:
   - a 32-bit customer ID
   - a 32-bit gift card ID

   Using an RSKEY encoding 8 bytes of data, with 3 parity symbols, we get
   protection against 1 error or 2 erased symbols, with 1 parity symbol left
   over for validation.

   See =rskey_node.js= for sample code (the communication of the JSON request
   and reply between the client Website and the Node.JS server is left as an
   excercise to the reader.)

*** Client Website RSKEY Implementation

    On the client website, you would use something like:

#+BEGIN_SRC Javascript
<script
  src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.1.1/js/ezpwd/rskey.js">
</script>
<script>
var client = {
    // 
    // card_key_encode( card ) -- encrypt card's IDs on the server, return RSKEY
    // card_key_decode( key )  -- recover RSKEY, decrypt IDs on server, return card
    // 
    //     These are run in the browser, and expect to call server methods that
    // run under node.js back on the server.  For this demo, we'll all just run
    // here in node.js...
    // 
    card_key_encode: function( card ) {
        // Get the server to encrypt the card IDs
        server.card_keydata_encode( card );
        // Produce the RSKEY from the card's keydata w/ Uint8Array's ArrayBuffer
        card.key = rskey_3_encode( 8, new Uint8Array( card.keydata ).buffer, 4 );
        return card.key;
    },

    card_key_decode: function( key ) {
        // Decode the ASCII key; will raise an Exception if decode fails
        var keyinfo = rskey_3_decode( 8, key );

        // Convert ArrayBuffer (as Uint8Array) to plain javascript Array
        var keyuint8 = new Uint8Array( keyinfo.data );
        var keydata = Array( 8 );
        for ( var i = 0; i < 8; ++i )
            keydata[i]	= keyuint8[i];

        // Get the server to decrypt the card.keydata, return the card IDs
        return server.card_keydata_decode({ keydata: keydata });
    }
}

// Your first customer ever, buys his first gift card!
card = {
    id: 0,
    customer: { id: 0 },
}

// Encode the card IDs to RSKEY
card_key = client.card_key_encode( card );

// "P5X1-TPW8-5NFP-2M7G" is printed/emailed on gift card
#+END_SRC

    Later on, the gift card recipient comes back to the website and enters the
    gift-card key during checkout, mistyping some symbols, and using lower-case
    and alternative whitespace (the base-32 encoding handles the Z/z/2, S/s/5,
    I/i/1 and O/o/0 substitutions (these symbols are equivalent in EZPWD
    base-32); the W/v substitution is an error):

#+BEGIN_SRC Javascript
// Decode the customer-entered data using the same RSKEY parameters:
//                          error:         v
//                    equivalents:   v v      v    v
//                       original: "P5X1-TPW8-5NFP-2M7G"
card_dec = client.card_key_decode( "psxl tpv8 snfp zm7g" );

// This is gift card ID 0, purchased by our very first customer ID 0! Find out
// what that gift card is still worth, and apply it to the order...
#+END_SRC

*** Server Node.js Encryption Implementation

    All encryption should take place on the server, with a secret symmetric
    encryption key (which should not be stored in the repo!  Use other secure
    key storage, or existing key material already on the server).  Encrypt on
    the server using an appropriate cipher that either encrypts all 64 bits as
    a block (such as =blowfish=).

#+BEGIN_SRC Javascript

/*
 * rskey_node.js -- Demonstrate use of rskey in node application
 * 
 *     Node "crypto" uses the Buffer type to manipulate binary data.  The rskey
 * library uses ArrayBuffer, because it is intended to be used in both Node and
 * Browser Javascript applications.
 * 
 *    The server will expect an Object containing (at least) card.id and
 * card.customer.id, and produce/consume card.keydata.
 * 
 */
var rskey		= require( './js/ezpwd/rskey.js' );
var crypto		= require( "crypto" );
var crypto_algo		= 'blowfish'; // 64-bit block cipher
var crypto_secret	= 'not.here'; // Super secret master key; don't keep in Git...

var server = {
    //
    // card_keydata_encode -- Encipher card IDs into card.keydata Array
    // card_keydata_decode -- Decipher card IDs from card.keydata Array
    // 
    //     Run these on your server (of course, keeping crypto_secret... secret.)
    // 
    card_keydata_encode: function( card ) {
        // Create Buffer containing raw card ID data
        var buf		= new Buffer( 8 );
        buf.writeUInt32LE( card.customer.id,	0 );
        buf.writeUInt32LE( card.id,		4 );

        // Encrypt the Buffer of keydata
        var encipher	= crypto.createCipher( crypto_algo, crypto_secret );
        encipher.setAutoPadding( false ); // must use exact 64-bit blocks
        var enc		= Buffer.concat([ 
            encipher.update( buf ),
            encipher.final()
        ]);

        // Return card w/ encrypted IDs as plain Javascript Array in .keydata
        card.keydata	= enc.toJSON();
        return card;
    },

    card_keydata_decode: function( card ) {
        if ( card.keydata.length != 8 )
            throw "Expected 8 bytes of card.keydata, got: " + card.keydata.length;

        // Decrypt the Buffer of keydata
        var decipher	= crypto.createDecipher( crypto_algo, crypto_secret );
        decipher.setAutoPadding( false ); // must use exact 64-bit blocks
        var dec		= Buffer.concat([
            decipher.update( new Buffer( card.keydata )),
            decipher.final()
        ]);

        // Recover raw card IDs from Buffer
        if ( card.customer == undefined )
            card.customer = {};
        card.customer.id= dec.readUInt32LE( 0 );
        card.id		= dec.readUInt32LE( 4 );
        return card;
    }
};
#+END_SRC    

    Assuming that an attacker does not have access to the encryption key used
    by the server to encrypt the customer and card IDs in a single 64-bit
    block, then the probability of a fake key being produced and accepted is
    vanishingly small.

    Lets assume that they *do* know that you are using EZPWD Reed-Solomon, and
    therefore always present RSKEYs that are valid R-S codewords.  Furthermore,
    lets assume that you have alot of customers (> 2 billion), so your 32-bit
    customer ID is likely to accidentally match a valid customer with a
    probability >50%.

    The decrypted customer and card IDs must be correct -- match a valid
    customer and card ID.  Since it is unlikely for each customer to generate
    more than a handful of gift cards, the probability that the 32-bit card ID
    will accidentally decrypt to any given value is 1/2^32 (1 in ~4
    billion). The combined 64-bit RSKEY (remember: all data must be encrypted
    with a block cipher)indexes a sparsely populated array of
    valid values; given a number in the range (0,2^64], only every 4-billionth
    value will turn out to be valid (much less than that, in realistic
    scenarios).

    Therefore, an attacker must generate and try more than 2 billion valid
    RSKEYs before they have a 50% chance of stumbling upon one that matches a
    valid gift card, given the above (generous) assumptions.  Even if you don't
    rate-limit your card redemption API, you might notice that your server is
    saturated with gift-card redemption requests.  Assuming that your server
    can process 1000 redemptions per second, it would take the attacker 23 days
    (2,000,000 seconds) to have a 50% chance of finding his first valid fake
    key.  So, I recommend rate-limiting your gift-card redemption API to 10
    request per second, increasing the time to 6 years.

    Therefore, using RSKEY and a simple encoding scheme presents an effective,
    robust and secure means of generating and redeeming gift-card codes.

    Customer aggravation due to mis-typed codes is reduced, increasing the
    likelihood of return visits and positive reviews.

* EXCOD: Javascript Location Code API

  To specify the location of something on the surface of the earth, a Latitude,
  Longitude pair is typically used.   To get within +/-3m, a Latitude, Longitude
  pair with at least 5 digits of precision after the decimal point is required.

  So, to specify where my daughter Amarissa was born, I can write down the
  coordinate:
  : 53.655832,-113.625433

  This is both longer and more error prone than writing the equivalent EZCOD:
  : R3U 1JU QUY.0

  If a digit is wrong in the Latitude or Longitude coordinate, the amount of error
  introduced is anywhere from a few centimeters to many kilometers:
  : 53.655832,-113.62543X == centimeters error
  : 53.655832,-1X3.625433 == many kilometers error

  EZCOD uses error/erasure correction to correct for up to 1 known missing
  (erased) symbol by default, with greater erasure/error detection and
  correction optionally available.

** Javascript Library: js/ezpwd/ezcod.js:

   : ezcod_3_10_encode( lat, lon, [ symbols ] ) -- encode location to EZCOD
   : ezcod_3_10_decode( ezcod )                 -- decode EZCOD to position

   There are three variants provided:
   - =ezcod_3_10_...= -- 1 parity symbol
   - =ezcod_3_11_...= -- 2 parity symbols
   - =ezcod_3_12_...= -- 3 parity symbols

   Load the ezcod.js Javascript into your project:
   #+BEGIN_SRC HTML
   <script
    src="//cdn.rawgit.com/pjkundert/ezpwd-reed-solomon/v1.1.1/js/ezpwd/ezcod.js">
   </script>
   #+END_SRC

   To encode a position of center of the Taj Mahal dome to 3m accuracy (9
   position symbols, the default) and 20mm accuracy (12 symbols), and with 3
   parity symbols (5-nines confidence):
   #+BEGIN_SRC Javascript
   > ezcod_3_12_encode( 27.175036985,  78.042124565 ) // default: 3m (9 symbols)
   "MMF BBF GC1.2U2"
   > ezcod_3_12_encode( 27.175036985,  78.042124565, 12 ) // 20mm (12 symbols)
   "MMF BBF GC1 A16.1VD"
   #+END_SRC
  
   Later, if the EZCOD is entered, errors and erasures are transparently
   corrected, up to the capacity of the Reed-Solomon encoded parity:
   #+BEGIN_SRC Javascript
   > ezcod_3_12_decode( "MMF BBF GC1 A16.1VD" )
   Object {confidence: 100, latitude: 27.17503683641553, longitude: 78.04212455637753,
       accuracy: 0.020401379521588606}
   > ezcod_3_12_decode( "MMF BBF GC1 A16.1" ) // missing some parity
   Object {confidence: 34, latitude: 27.17503683641553, longitude: 78.04212455637753,
       accuracy: 0.020401379521588606}
   > ezcod_3_12_decode( "mmf-bbf-Xc1-a16.1vd" ) // An error
   Object {confidence: 34, latitude: 27.17503683641553, longitude: 78.04212455637753,
       accuracy: 0.020401379521588606}
   #+END_SRC
  
   Try it at [[http://ezcod.com][ezcod.com]].  Switch to "EXCOD 3:12", and enter "mmf-bbf-Xc1-a16.1vd"
   as the EXCOD.  You will see a computed accuracy of 20.4mm, and observe that
   the 'X' (error) is corrected to "G".  (The website defaults to 9 digits of
   precision, so it will re-encode the position, discarding the extra
   precision.)

** Robustness

   All symbols after the initial 9 are Reed-Solomon code symbols.  Each R-S
   symbol can recover one known erasure; every two R-S symbols can detect and
   correct one other erroneous symbol.  If any R-S symbols remains unused in
   excess of all erasures and errors, then the entire sequence can be confirmed
   as an R-S "codeword", and its validity is assured, to a probability of:
   : P(1-1/2^(5*excess))

   For example, with one R-S symbol remaining, the probability that the EZCOD
   is correct is:
   : P(1-1/2^5) == .969
   If two excess R-S symbols exist, then the
   probability rises to:
   : P(1-1/2^10) == P(1-1/1024) == 0.999
   With 3, it's:
   : P(1-1/2^15) == P(1-1/32768) == 0.99997

   Therefore, if extremely robust positions are required, select an EZCOD with
   3 parity symbols, yielding almost 5-nines reliability in transmitting
   accurate position information -- even if it must be written down, recited or
   entered by a human.

** Precision

   To identify the location of something within +/- 10 feet (3m) is simple: you
   must specify the Latitude (-90,90) to within 1 part in 4,194,304 (2^22) and
   Longitude (-180,180) to within 1 part in 8,388,608 (2^23).

   The default 10-symbol EZCOD transmits 22 bits of Latitude and 23 bits of
   Longitude in 9 symbols of position data (the 10th is a parity symbol).  The
   EZCOD API can encode up to 12 symbols of position data (29 bits of Latitude,
   and 31 bits of Longitude), yielding a maximum precision capability of +/- 20
   millimeters.

   Since the earth's circumference at the equator is ~40,075,000m, each part in
   both vertical and horizontal directions is 40,075,000 / 8,388,608 == 4.777m.  If
   you can specify a rectangle having sides of length equal to one part in the
   vertical and horizontal direction, then at the equator, you have a square that
   is 4.777m on a side.  So, if we know which square some geographical coordinate
   lies within, it is at most sqrt( 2 * (4.777/2)^2 ) == 3.378m distant from the
   center of the square.

   As you travel north or south, the circumference of the Longitude lines
   decreases, as absolute Latitude increases.  The average radius of the earth is
   ~6,371,000m.  At 53 degrees North, the circumference of the earth along a line
   of fixed Latitude is:
   : 2 * pi * radius * cos( Latitude )
   : 2 * 3.1415926534 * 6,371,000m * 0.60181502315
   : 24,090,760m

   Thus, each part along the vertical axis is still 4.777m, but each horizontal
   part is:
   : 24,090,760 / 8,388,608 == 2.872m.

   Now the point within each rectangle is at most:
   : sqrt( (4.777/2)^2 + (2.872/2)^2 ) == 2.787m
   distant from the center of the rectangle.

   Thus, with 9 symbols of position data, the precision of such a
   Latitude/Longitude encoding is at worst +/- 3.378m at the equator, at best
   +/-2.389m at the poles, and has an average error of less than +/-3m.

** EZCOD Demo: http://ezcod.com

   To see EZCOD in action, visit [[http://ezcod.com][ezcod.com]].  Try entering:
   : R3U 1JU QUY.0
   to see where my daughter Amarissa was born.

   You can also access the Console (right click, select Inspect Element, click
   on "Console"), and enter the above =rskey_=... API example code.

* RSPWD: Javascript Password Correction API

  Javascript implementation of Reed-Solomon codec based password error
  detection and correction.

** Javascript Library: js/ezpwd/rspwd.js
