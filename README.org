#+TITLE: ezpwd-reed-solomon.js
#+STYLE: <link rel="stylesheet" type="text/css" href="org.css" />

* Reed-Solomon Loss/Error Correction Coding

  Error and erasure detection and correction for C++ and Javascript programs.
  Based on Phil Karn's excellent implementation (as used by the Linux kernel),
  converted to C++.

  Performs about 40% faster than Phil's general case code, about 20% faster than
  his optimized code for 8-bit/CCSDS symbols.

  Available both under GPLv3 and Commercial licenses (Phil's original code)

** c++/ezpwd/rs

   C++ implementation of Reed-Solomon codec.  Fully implemented as inline code,
   in C++ header files.

   #+BEGIN_SRC C++
   #include <ezpwd/rs>

   ezpwd::RS<255,251> rs;	// Reed Solomon w/ 255 8-bit symbols, up to 251 data
   std::vector<uint8_t> data;	// fill data with  up to 251 bytes ...
   rs.encode( data );		// Add 4 Reed-Solomon parity symbols (255-251 == 4)

   // ... later, after data is possibly corrupted ...

   int fix = rs.decode( data ); // Correct errors, discard 4 R-S parity symbols

   #+END_SRC

** js/ezpwd/rspwd.js

   Javascript implementation of Reed-Solomon codec based password error
   detection and correction.  Produced from the C++ implementation using =emscripten=.

** Enhancements

   Several enhancements have been made.

*** Rejects impossible error position

    Phil's version allows the R-S decode to compute and return error positions
    with the unused portion of the Reed-Solomon codeword.  We reject these
    solutions, as they provide indication of a failure.

    The supplied data and parity may not employ the full potential codeword size
    for a given Reed-Solomon codec.  For example, and RS(31,29) codec is able to
    decode a codeword of 5-bit symbols containing up to 31 data and parity
    symbols; in this case, 2 parity symbols (31-29 == 2).

    If we supply (say) 9 data symbols and 2 parity symbols, the remaining 20
    symbols of unused capacity are effectively filled with zeros for the
    Reed-Solomon encode and decode operations.

    If we decode such a codeword, and the R-S Galois field solution indicates an
    error positioned in the first 20 symbols of the codeword (an impossible
    situation), we reject the codeword and return an error.

*** Shared data tables w/ optional locking

    Instead of re-computing all of the required data tables used by the
    Reed-Solomon computations, every instance of RS(SIZE,*) with compatible
    Galois polynomial parameters shares a common set of tables.  Furthermore,
    every instance of RS(SIZE,LOAD) w/ compatible Galias polynomiam parameters
    shares the tables specific to the computed number of parity symbols.

    The initialization of these tables is protected by a Mutex primitive and
    Guard object.  These default to 'int' (NO-OP), but if a threading mutex and
    guard are provided, the shared initialization is thread-safe.

